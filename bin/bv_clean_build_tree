#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys, os, re, shutil
from optparse import OptionParser
from datetime import datetime
import dateutil.parser
import subprocess

parser = OptionParser( description = 'Clean build directory / directories'
    'If no dir is specified, the current directory is assumed.'
    'Dead links and obsolete python modules (.pyc and .pyo files without a '
    'valid .py file next to them) are removed.',
    usage='%prog [options] [dirnames]' )
parser.add_option( '-a', '--accesstime', dest='accesstime',
    help='delete files that have older access time than the one specified.',
    default = '1971-01-01 00:00:00' )
parser.add_option( '-b', '--bin', dest='binaries', action='store_true',
    help='also check if all entries in bin/ are still present in Makefile, or '
    'obsolete, and erase them if not. Needs to have configured and up-to-date '
    'Makefiles' )
parser.add_option( '-d', '--dir', dest='directories', action='store_true',
    help='remove empty directories. Do not use this option during '
    'compilation, since it may remove some useful, temporarily empty, '
    'directories...' )
parser.add_option( '-l', '--list', dest='list', action='store_true',
    help='only list files and directories that will be deleted, do not delete '
    'those.' )

(options, args) = parser.parse_args()

if len( args ) == 0:
  basedirs = [ '.' ]
else:
  basedirs = args

excluded_base_dirs = ['lib', 'bin', 'local', 'src', '.svn', '.git']
excluded_dirs = []
for d in basedirs:
    excluded_dirs += [os.path.join(d, ed) for ed in excluded_base_dirs]

basedirs0 = list(basedirs)
basermdirs = set()
accesstime = dateutil.parser.parse(options.accesstime)

def clean_lib_dir(directory):
    if sys.platform.startswith('linux'):
        libre = re.compile('^lib(.*)\.so\..*$')
        liblink = 'lib%s.so'
    elif sys.platform == 'darwin':
        libre = re.compile('^lib(.*)(\.[0-9]+)+\.dylib$')
        liblink = 'lib%s.dylib'
    elif sys.platform.startswith('win'):
        libre = re.compile('lib(.*)((\.[0-9]+)+)\.dll$')
        liblink = None
        libs = {}
    for f in os.listdir(directory):
        m = libre.match(f)
        if m:
          if liblink:
              link_f = os.path.join(directory, liblink % m.group(1))
              if os.path.islink(link_f) and os.readlink(link_f) != f:
                  print 'obsolete lib:', f
                  os.unlink(os.path.join(directory, f))
          else:
              libs.setdefault(m.group(1), []).append((f, m.group(2)))
    #if liblink is None: # windows: sort DLL versions
        #for libname, libs_def in libs.iteritems():
            #lib_vers = [l[1] for l in libs_def]
            #versions = sorted(lib_vers)
            #for ver in versions[:-1]:
                #i = lib_vers.index(ver)
                #print 'obsolete lib:', libs_def[i][0]
                #os.unlink(os.path.join(directory, libs_def[i][0]))


def clean_share_dir(directory):
    comp_re = re.compile('^(.*)-([0-9.]+)$')
    comps = {}
    for f in os.listdir(directory):
        m = comp_re.match(f)
        if m:
            comps.setdefault(m.group(1), []).append((f, m.group(2)))

    for comp_name, comp_def in comps.iteritems():
        comp_vers = [l[1] for l in comp_def]
        versions = sorted(comp_vers)
        for ver in versions[:-1]:
            i = comp_vers.index(ver)
            print 'obsolete directory:', comp_def[i][0]
            shutil.rmtree(os.path.join(directory, comp_def[i][0]))


while basedirs:
    d = basedirs.pop()
    if isinstance(d, tuple):
        d, excluded = d
    else:
        excluded = False
    if d in excluded_dirs:
        excluded = True

    dircontent = os.listdir(d)
    if 'lib' in dircontent and 'lib' not in excluded_dirs:
        clean_lib_dir(os.path.join(d, 'lib'))
    if 'share' in dircontent and 'share' not in excluded_dirs:
        clean_share_dir(os.path.join(d, 'share'))
        if os.path.isdir(os.path.join(d, 'share', 'doc')):
            clean_share_dir(os.path.join(d, 'share', 'doc'))

    for f in dircontent:
        path = os.path.join(d, f)
        if os.path.isdir(path):
            basedirs.append((path, excluded))
        elif os.path.islink(path):
            if not os.path.exists(path):
                print 'rm dead link', path
                if not options.list:
                    os.unlink(path)
        elif f.endswith('.pyc') or f.endswith('.pyo'):
            pyfile = path[:-1]
            if not excluded and not os.path.exists(pyfile):
                print 'rm obsolete module', path
                if not options.list:
                    os.unlink(path)
        elif datetime.fromtimestamp(os.stat(path).st_atime) < accesstime:
            print 'rm obsolete file', path
            if not options.list:
                os.unlink(path)

    dircontent = os.listdir(d)
    if len(dircontent) == 0:
        if options.directories:
            print 'rmdir', d
            if not options.list :
                os.rmdir(d)

            if d != os.path.dirname(d):
                basermdirs.add(os.path.dirname(d))

while basermdirs:
    d = basermdirs.pop()
    if os.path.isdir(d):
        dircontent = os.listdir(d)
        if len(dircontent) == 0:
            if options.directories:
                print 'rmdir', d
                if not options.list :
                    os.rmdir(d)
                if d != os.path.dirname(d):
                    basermdirs.add(os.path.dirname(d))

def parse_cmake_executables(directory):
    cmake_cache = os.path.join(directory, 'CMakeCache.txt')
    if not os.path.exists(cmake_cache):
        # no cmake cache: no built executables
        return []
    cmds_re = re.compile('^.*-commands:INTERNAL=(.+)$')
    all_cmds = []
    for line in open(cmake_cache).xreadlines():
        m = cmds_re.match(line)
        if m:
            cmds = m.group(1).split(';')
            all_cmds += cmds
    return all_cmds

if options.binaries:
    cwd = os.getcwd()
    skipped = {}
    for d in basedirs0:
        os.chdir(d)
        bindir = os.path.join(d, 'bin')
        if os.path.exists(bindir):
            all_cmds = parse_cmake_executables(d)
            for f in os.listdir(bindir):
                if not os.path.islink(os.path.join(bindir, f)):
                    if f.startswith('bv_'):
                        sk = skipped.setdefault(bindir, [])
                        sk.append(f)
                        #print 'skipping', f, '(may be part of bv_cmake)'
                    else:
                        if f not in all_cmds:
                            print 'rm obsolete command', f
                            if not options.list :
                                os.unlink(os.path.join(bindir, f))
    for d, items in skipped.iteritems():
        print '-- skipped from', d
        for f in items:
            print 'skipped', f, '(may be part of bv_cmake)'
    os.chdir(cwd)


