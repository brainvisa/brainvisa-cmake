#! /usr/bin/env python
# -*- coding: utf-8 -*-

from __future__ import absolute_import, division
from __future__ import print_function, unicode_literals

import binascii
import codecs
import io
import locale
import sys
import os
import re
import pprint
import subprocess
import glob
import shutil
import json
from optparse import OptionParser
from fnmatch import fnmatchcase
import tempfile
import datetime
import distutils.spawn
import shlex
import time
import traceback
from smtplib import SMTP
import gzip
import multiprocessing  # for cpu_count()

import six
from six.moves import reload_module, shlex_quote, zip
from six.moves.urllib.request import urlopen

# the following imports are just to make functions available in tests
# using eval() in filters/conditions
from socket import gethostname


if os.path.exists(sys.argv[0]):
    this_script = sys.argv[0]
else:
    this_script = None
    for p in os.environ.get('PATH', '').split(os.pathsep) + [os.curdir]:
        s = os.path.join(p, sys.argv[0])
        if os.path.exists(s):
            this_script = s
            break
if this_script:
    this_script = os.path.abspath(this_script)
    python_modules = os.path.join(
        os.path.dirname(os.path.dirname(this_script)), 'python')
    if os.path.isdir(python_modules):
        sys.path.insert(0, python_modules)


import brainvisa.maker.brainvisa_projects as brainvisa_projects
from brainvisa.maker.build import check_ld_library_path_error
import brainvisa.maker.components_definition
import brainvisa.maker.commands
import brainvisa.maker.configuration
from brainvisa.maker.environment import environmentPathVariablesSubstitution
from brainvisa.maker.environment import normalize_path
from brainvisa.maker.environment import replace_vars
from brainvisa.maker.environment import VarReplacementType
import brainvisa.maker.installer as installer
from brainvisa.maker.subprocess import subprocess32
from brainvisa.maker.subprocess import system
from brainvisa.maker.subprocess import system_output_on_error
from brainvisa.maker.version_number import version_format_short


ASCII_SUBSTITUTIONS = {
    ord('┌'): '/',
    ord('─'): '-',
    ord('│'): '|',
    ord('✓'): 'v',
    ord('✗'): 'X',
}


def substitute_ascii_error_handler(error):
    """Unicode error handler that replaces a few characters with ASCII.

    Characters not in ASCII_SUBSTITUTIONS are handled by the 'replace' error
    handler (i.e. replaced by '?').
    """
    if isinstance(error, UnicodeEncodeError):
        unencodable = error.object[error.start:error.end]
        substitute = unencodable.translate(ASCII_SUBSTITUTIONS)
        replaced_substitute = substitute.encode(error.encoding, 'replace')
        if six.PY2:
            return (replaced_substitute.decode(error.encoding), error.end)
        return (replaced_substitute, error.end)
    else:
        raise error


codecs.register_error('substitute_ascii', substitute_ascii_error_handler)


def reconfigure_stdout():
    """Reconfigure stdout so it does not crash on foreign Unicode characters.

    Also enable line-buffering, so that the output from print() and
    subprocesses will be interspersed correctly.
    """
    # Python 3.7 and later
    if hasattr(sys.stdout, 'reconfigure'):
        sys.stdout.reconfigure(errors='substitute_ascii', line_buffering=True)
        return

    try:
        fileno = sys.stdout.fileno()
    except (AttributeError, IOError):
        fileno = None

    # Under Python 2 many libraries (e.g. optparse) will try to write
    # strings of type 'str' to stdout, so we need to replace it with an
    # object that handles both unicode and str.
    if six.PY2:
        linebuf_stdout = sys.stdout
        if fileno is not None:
            linebuf_stdout = os.fdopen(fileno, 'w', 1)
        encoding = getattr(sys.stdout, 'encoding', None)
        if encoding is None:
            encoding = locale.getpreferredencoding()
        new_stdout = codecs.getwriter(encoding)(
            linebuf_stdout, errors='substitute_ascii')
    else:
        # Python 3.0 to 3.6
        new_stdout = io.open(fileno, mode='wt', buffering=1,
                             encoding=sys.stdout.encoding,
                             errors='substitute_ascii',
                             closefd=False)
    sys.stdout.flush()
    sys.stdout = new_stdout


reconfigure_stdout()


class InfoCommand(brainvisa.maker.commands.StepCommand):

    def __init__(self, argv, configuration):
        usage = '''%prog [global options] info [options]

    Display information about configuration, sources directories and build directories.'''
        parser = OptionParser(usage=usage)
        parser.add_option('--only-if-default', dest='in_config',
                          action='store_true',
                          default=False,
                          help='only perform this step if it is a default '
                          'step, or specified in the "default_steps" option '
                          'of bv_maker.cfg config file. Default steps are '
                          'normally "sources" for source sections, and '
                          '"configure build" for build sections')
        (options, args) = parser.parse_args(argv)
        if args:
            raise ValueError('Invalid option: %s' % args[0])
        
        super(InfoCommand, self).__init__(argv, configuration)
        self.options = options
        self.args = args

    def __call__(self):
        print('Configuration file:', configuration.configuration_file)
        dirs = dict(configuration.sourcesDirectories)
        dirs.update(configuration.buildDirectories)
        dirs.update(configuration.packageDirectories)
        dirs.update(configuration.publicationDirectories)
        self.process('info', list(dirs.values()), 'info')


class SourcesCommand(brainvisa.maker.commands.StepCommand):

    def __init__(self, argv, configuration):
        usage = '''%prog [global options] sources [options]

    Create or updated selected sources directories from Subversion repository.'''
        parser = OptionParser(usage=usage)
        parser.add_option('--no-cleanup', dest='cleanup', action='store_false',
                          default=True,
                          help='don\'t cleanup svn sources')
        parser.add_option('--no-svn', dest='svn', action='store_false',
                          default=True,
                          help='don\'t update svn sources')
        parser.add_option('--no-git', dest='git', action='store_false',
                          default=True,
                          help='don\'t update git sources')
        parser.add_option('--only-if-default', dest='in_config',
                          action='store_true',
                          default=False,
                          help='only perform this step if it is a default '
                          'step, or specified in the "default_steps" option '
                          'of bv_maker.cfg config file. Default steps are '
                          'normally "sources" for source sections, and '
                          '"configure build" for build sections')
        parser.add_option('--ignore-git-failure', dest='ignore_git_failure',
                          action='store_true', default=False,
                          help='ignore git update failures, useful when '
                          'working on a feature branch')
        (options, args) = parser.parse_args(argv)
        if args:
            raise ValueError('Invalid option: %s' % args[0])
        
        super(SourcesCommand, self).__init__(argv, configuration)
        self.options = options
        self.args = args

    def __call__(self):
        self.process('sources', list(configuration.sourcesDirectories.values()),
                     'process', self.options, self.args)


class SourceStatusCommand(brainvisa.maker.commands.StepCommand):

    def __init__(self, argv, configuration):
        usage = '''%prog [global options] status [options]

    Display a summary of the status of all source repositories.'''
        parser = OptionParser(usage=usage)
        parser.add_option('--no-svn', dest='svn', action='store_false',
                          default=True,
                          help="don't display the status of svn sources")
        parser.add_option('--no-git', dest='git', action='store_false',
                          default=True,
                          help="don't display the status of git sources")
        parser.add_option('--only-if-default', dest='in_config',
                          action='store_true',
                          default=False,
                          help='only perform this step if it is a default '
                          'step, or specified in the "default_steps" option '
                          'of bv_maker.cfg config file. Default steps are '
                          'normally "sources" for source sections, and '
                          '"configure build" for build sections')
        parser.add_option('--git-command', dest='extra_git_commands',
                          default=[], action='append',
                          help="run one or more extra commands in every Git "
                               "repository. The commmands are interpreted in "
                               "a shell so that you can pass arguments.")
        (options, args) = parser.parse_args(argv)
        if args:
            raise ValueError('Invalid option: %s' % args[0])

        super(SourceStatusCommand, self).__init__(argv, configuration)
        self.options = options
        self.args = args

    def __call__(self):
        self.process('status',
                     list(configuration.sourcesDirectories.values()),
                     'source_status', self.options, self.args)


class ConfigureCommand(brainvisa.maker.commands.StepCommand):

    def __init__(self, argv, configuration):
        usage = '''%prog [global options] configure [options]

    Create or updated selected build directories.'''
        parser = OptionParser(usage=usage)
        parser.add_option('-c', '--clean', dest='clean', action='store_true',
                          default=False,
                          help='clean build tree (using bv_clean_build_tree '
                          '-d) before configuring')
        parser.add_option('--only-if-default', dest='in_config',
                          action='store_true',
                          default=False,
                          help='only perform this step if it is a default '
                          'step, or specified in the "default_steps" option '
                          'of bv_maker.cfg config file. Default steps are '
                          'normally "sources" for source sections, and '
                          '"configure build" for build sections')
        (options, args) = parser.parse_args(argv)
        if args:
            raise ValueError('Invalid option: %s' % args[0])
        
        super(ConfigureCommand, self).__init__(argv, configuration)
        self.options = options
        self.args = args

    def __call__(self):
        self.process('configure', list(configuration.buildDirectories.values()),
                     'configure', self.options, self.args)

class BuildCommand(brainvisa.maker.commands.StepCommand):

    def __init__(self, argv, configuration):
        usage = '''%prog [global options] configure [options]

    Compile selected build directories.'''
        parser = OptionParser(usage=usage)
        parser.add_option('-c', '--clean', dest='clean', action='store_true',
                          default=False,
                          help='clean build tree (using '
                          'bv_clean_build_tree -b) before building')
        parser.add_option('--only-if-default', dest='in_config',
                          action='store_true',
                          default=False,
                          help='only perform this step if it is a default '
                          'step, or specified in the "default_steps" option '
                          'of bv_maker.cfg config file. Default steps are '
                          'normally "sources" for source sections, and '
                          '"configure build" for build sections')
        (options, args) = parser.parse_args(argv)
        if args:
            raise ValueError('Invalid option: %s' % args[0])
        
        super(BuildCommand, self).__init__(argv, configuration)
        self.options = options
        self.args = args

    def __call__(self):
        self.process('build', list(configuration.buildDirectories.values()),
                     'build', self.options, self.args)


class DocCommand(brainvisa.maker.commands.StepCommand):

    def __init__(self, argv, configuration):
        usage = '''%prog [global options] doc [options]

    Generate documentation (docbook, epydoc, doxygen).'''
        parser = OptionParser(usage=usage)
        parser.add_option('--only-if-default', dest='in_config',
                          action='store_true',
                          default=False,
                          help='only perform this step if it is a default '
                          'step, or specified in the "default_steps" option '
                          'of bv_maker.cfg config file. Default steps are '
                          'normally "sources" for source sections, and '
                          '"configure build" for build sections')
        (options, args) = parser.parse_args(argv)
        if args:
            raise ValueError('Invalid option: %s' % args[0])
        
        super(DocCommand, self).__init__(argv, configuration)
        self.options = options
        self.args = args

    def __call__(self):
        self.process('doc', list(configuration.buildDirectories.values()), 'doc')


class TestCommand(brainvisa.maker.commands.StepCommand):

    def __init__(self, argv, configuration):
        usage = '''%prog [global options] test

    Executes ctest.'''
        parser = OptionParser(usage=usage)
        parser.add_option('--only-if-default', dest='in_config',
                          action='store_true',
                          default=False,
                          help='only perform this step if it is a default '
                          'step, or specified in the "default_steps" option '
                          'of bv_maker.cfg config file. Default steps are '
                          'normally "sources" for source sections, and '
                          '"configure build" for build sections')
        parser.add_option('-t', '--ctest_options',
                          default=None,
                          help='options passed to ctest (ex: "-VV -R carto*"). '
                          'Same as the configuration option ctest_options but '
                          'specified at runtime. The commandline option here '
                          'overrides the bv_maker.cfg options.')
        (options, args) = parser.parse_args(argv)
        if args:
            raise ValueError('Invalid option: %s' % args[0])
        
        super(TestCommand, self).__init__(argv, configuration)
        self.options = options
        self.args = args

    def __call__(self):
        self.process('test', list(configuration.buildDirectories.values()), 'test',
                     self.options, self.args)


class TestrefCommand(brainvisa.maker.commands.StepCommand):

    def __init__(self, argv, configuration):
        usage = '''%prog [global options] testref

    Executes tests in the testref mode (used to generate reference files).'''
        parser = OptionParser(usage=usage)
        parser.add_option('--only-if-default', dest='in_config',
                          action='store_true',
                          default=False,
                          help='only perform this step if it is a default '
                          'step, or specified in the "default_steps" option '
                          'of bv_maker.cfg config file. Default steps are '
                          'normally "sources" for source sections, and '
                          '"configure build" for build sections')
        parser.add_option('-m', '--make_options',
                          default=None,
                          help='options passed to make (ex: "-j8") during test '
                          'reference generation. '
                          'Same as the configuration option make_options but '
                          'specified at runtime. The commandline option here '
                          'overrides the bv_maker.cfg options.')
        (options, args) = parser.parse_args(argv)
        if args:
            raise ValueError('Invalid option: %s' % args[0])
        
        super(TestrefCommand, self).__init__(argv, configuration)
        self.options = options
        self.args = args

    def __call__(self):
        self.process('testref', list(configuration.buildDirectories.values()), 'testref',
                     self.options, self.args)


def display_failure_summary(configuration):
    sections = [('sourcesDirectories', ['sources']),
                ('buildDirectories', ['configure', 'build', 'doc', 'testref',
                                      'test']),
                ('packageDirectories', ['pack', 'install_pack', 'testref_pack',
                                        'test_pack']),
                ('publicationDirectories', ['publish_pack']),
                ]
    global_failed = False
    status_map = {'not run': '',
                  'succeeded': 'OK         ',
                  'failed': 'FAILED     ',
                  'unmet dependency': 'UNMET DEP  ',
                  'interrupted': 'INTERRUPTED'}
    sys.stdout.flush()
    sys.stderr.flush()
    messages = ['\nbv_maker summary:']
    print(messages[0])
    #log_file = None
    #if configuration.general_section \
            #and configuration.general_section.global_status_file:
        #log_file = configuration.general_section.global_status_file
        #machine = gethostname()
        #osname = global_installer_variables()['os']
    first_start = None
    last_stop = None
    for section_name, steps in sections:
        for section in getattr(configuration, section_name).values():
            for step in steps:
                status = status_map[section.get_status(step)]
                if status != '':
                    message = '%s step %s: %s' % (status, step, 
                                                  section.directory)
                    start = section.start_time.get(step)
                    if start:
                        if first_start is None:
                            first_start = start
                        message += ', started: %04d/%02d/%02d %02d:%02d' \
                            % start[:5]
                    stop = section.stop_time.get(step)
                    if stop:
                        last_stop = stop
                        message += ', stopped: %04d/%02d/%02d %02d:%02d' \
                            % stop[:5]
                    messages.append(message)
                    print(message)
                    if section.has_failed(step):
                        global_failed = True
    if global_failed:
        status = 'There were errors.'
        print(status)
    else:
        status = 'All went good.'
        print(status)
    return global_failed

# ---

# export cpu_count() as NCPU env variable so that it can be used in conf file
# for env replacements
try:
    os.environ['NCPU'] = str(multiprocessing.cpu_count())
except NotImplementedError:
    # multiprocessing.cpu_count can raise NotImplementedError
    os.environ['NCPU'] = '1'

check_ld_library_path_error(fatal=False)

commands = {
    'info': InfoCommand,
    'sources': SourcesCommand,
    'status': SourceStatusCommand,
    'configure': ConfigureCommand,
    'build': BuildCommand,
    'doc': DocCommand,
    'test': TestCommand,
    'testref': TestrefCommand,
    'pack': installer.PackCommand,
    'install_pack': installer.InstallPackCommand,
    'test_pack': installer.TestPackCommand,
    'testref_pack': installer.TestrefPackCommand,
    'publish_pack': installer.PublishPackCommand,
}

default_commands = ['info', 'sources', 'configure', 'build', 'doc', 'test',
                    'pack', 'install_pack', 'test_pack']
options_by_command = {None: []}
command = None
for i in sys.argv[1:]:
    if i in commands:
        command = i
        if command in options_by_command:
            raise ValueError('Command %s used twice' % command)
        options_by_command[command] = []
    else:
        options_by_command[command].append(i)

# Initialize global configuration
configuration = brainvisa.maker.configuration.GlobalConfiguration(options_by_command[None])

# Parse commands options and prepare them for processing in the correct order
todo = []
if len(options_by_command) == 1:
    # No command selected => do all default commands
    for i in default_commands:
        options_by_command[i] = ['--only-if-default']

log_something = False
# Ordered command list
for command in ['info', 'status', 'sources', 'configure', 'build',
                'doc', 'test', 'testref', 'pack', 'install_pack', 'test_pack',
                'testref_pack', 'publish_pack']:
    if command in options_by_command:
        todo.append(
            commands[command](options_by_command[command], configuration))
        if command not in ('info', 'status') \
                and '-h' not in options_by_command[command] \
                and '--help' not in options_by_command[command]:
            log_something = True

failed = False
# Execute selected commands
try:
    for f in todo:
        f()
except KeyboardInterrupt:
    traceback.print_exc()
    failed = True

failed |= display_failure_summary(configuration)

if failed:
    sys.exit(1)
