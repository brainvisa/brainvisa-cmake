#!/usr/bin/env python
# -*- coding: utf-8 -*-

#  This software and supporting documentation are distributed by
#      Institut Federatif de Recherche 49
#      CEA/NeuroSpin, Batiment 145,
#      91191 Gif-sur-Yvette cedex
#      France
#
# This software is governed by the CeCILL-B license under
# French law and abiding by the rules of distribution of free software.
# You can  use, modify and/or redistribute the software under the 
# terms of the CeCILL-B license as circulated by CEA, CNRS
# and INRIA at the following URL "http://www.cecill.info". 
#
# As a counterpart to the access to the source code and  rights to copy,
# modify and redistribute granted by the license, users are provided only
# with a limited warranty  and the software's author,  the holder of the
# economic rights,  and the successive licensors  have only  limited
# liability.
#
# In this respect, the user's attention is drawn to the risks associated
# with loading,  using,  modifying and/or developing or reproducing the
# software by the user in light of its specific status of free software,
# that may mean  that it is complicated to manipulate,  and  that  also
# therefore means  that it is reserved for developers  and  experienced
# professionals having in-depth computer knowledge. Users are therefore
# encouraged to load and test the software's suitability as regards their
# requirements in conditions enabling the security of their systems and/or 
# data to be ensured and,  more generally, to use and operate it in the 
# same conditions as regards security.
#
# The fact that you are presently reading this means that you have had
# knowledge of the CeCILL-B license and that you accept its terms.

import sys, os, re, pprint, subprocess, glob
from optparse import OptionParser
from fnmatch import fnmatchcase

if os.path.isabs( sys.argv[0] ):
  this_script = sys.argv[0]
else:
  this_script = None
  for p in os.environ.get( 'PATH', '' ).split( os.pathsep ) + [ os.curdir ]:
    s = os.path.join( p, sys.argv[0] )
    if os.path.exists( s ):
      this_script = s
      break
if this_script:
  python_modules = os.path.join( os.path.dirname( os.path.dirname( this_script ) ), 'python' )
  if os.path.isdir( python_modules ):
    sys.path.insert( 0, python_modules )

from brainvisa.maker.brainvisa_projects import *
from brainvisa.maker.bioproj_parser import BRAINVISA_SVN_URL, SVN_URL

def system( *args, **kwargs ):
  print ' '.join( args )
  result = subprocess.call( args, **kwargs )
  if result != 0:
    raise OSError( 'Command failed: ' + ' '.join( ( repr(i) for i in args ) ) )


def environmentVariablesSubstitution( path ):
  result = path
  r = re.compile( r'\$([A-Za-z0-9_]*)' )
  offset = 0
  for m in r.finditer( path ):
    variableContent = os.environ.get( m.group(1) )
    if variableContent is not None:
      start, end = m.span()
      start += offset
      end += offset
      offset += len( variableContent ) - end + start
      result = result[ :start ] + variableContent + result[ end :  ]
  return result



class SourceDirectory( object ):
  def __init__( self, directory, username='' ):
    self.directory = os.path.normpath( os.path.abspath( directory ) )
    if options.verbose:
      print 'Opening client:', self.directory
    self.username = username
    self.rules = []
    self.componentVersionPerURL = {}
    self.otherComponentsDirectory = set()
  
  
  def addRule( self, line ):
    l = line.split()
    if len(l) < 2 or len( l ) > 3:
      raise SyntaxError()
    sign = l[0]
    componentsPattern = l[1]
    if len( l ) == 3:
      versionPattern = l[2]
    else:
      versionPattern = None
    if sign == '+':
      if '/' in componentsPattern:
        if '*' in componentsPattern:
          raise SyntaxError()
        url = SVN_URL + '/' + componentsPattern
        if options.verbose:
          print '    adding url:', url
        self.otherComponentsDirectory.add( ( componentsPattern, versionPattern )  )
      else:
        if versionPattern is None:
          raise SyntaxError()
        for component in self.getBrainVISAComponents( componentsPattern ):
          if options.verbose:
            print '    considering component:', component
          for url in self.getMatchingURLs( component, versionPattern ):
            if options.verbose:
              print '      adding url:', url
            self.componentVersionPerURL[ url[2] ] = ( url[0], url[1] )
    elif sign == '-':
      if '/' in componentsPattern:
        raise SyntaxError()
      else:
        if versionPattern is None:
          versionPattern = '*'
        for component in self.getBrainVISAComponents( componentsPattern ):
          if options.verbose:
            print '    considering component:', component
          for url in self.getMatchingURLs( component, versionPattern ):
            if options.verbose:
              print '      removing url:', url
            self.componentVersionPerURL.pop( url[2], None )
    else:
      raise SyntaxError()
    self.rules.append( line )
  
  def process( self, commands ):
    print '[ source', self.directory, ']'
    if not os.path.exists( self.directory ):
      os.makedirs( self.directory )
    clientFile = open( os.path.join( self.directory, 'bv_maker.cfg' ), 'w' )
    print >> clientFile, '\n'.join( self.rules )
    
    repositoryDirectory = os.path.join( self.directory, '.repository' )
    checkout = False
    if not os.path.exists( repositoryDirectory ):
      system( 'svnadmin', 'create', repositoryDirectory )
      self.svncommand( 'checkout',  'file://' + os.path.splitdrive(repositoryDirectory)[1].replace(os.path.sep, "/"), self.directory )
      checkout = True
    self.updateExternals( update=checkout or 'svn' in commands )
    self.updateCMake()
    
  
  @staticmethod
  def getBrainVISAComponents( componentsPattern ):
    components = brainvisaComponentsPerGroup.get( componentsPattern )
    if components is None:
      components = brainvisaComponentsPerProject.get( componentsPattern )
      if components is None:
        if componentsPattern in brainvisaProjectPerComponent:
          components = [ componentsPattern ]
        else:
          l = componentsPattern.split( ':' )
          if len( l ) > 2:
            raise SyntaxError()
          if len( l ) == 1:
            projectPattern = '*'
            componentPattern = l[ 0 ]
          else:
            projectPattern, componentPattern = l
          components = []
          for project, projectComponents in brainvisaComponentsPerProject.iteritems():
            if fnmatchcase( project, projectPattern ):
              for component in projectComponents:
                if fnmatchcase( component, componentPattern ):
                  components.append( component )
    return components
  
  
  _urlsAlias = {
    'development': 'trunk',
    'bug_fix': 'branch:-1',
    'latest_release': 'tag:-1',
    'tag': 'tag:-1',
    'branch': 'branch:-1',
    'stable': 'branch:-1',
  }
  @staticmethod
  def getMatchingURLs( component, versionPattern ):
    versionPattern = SourceDirectory._urlsAlias.get( versionPattern, versionPattern )
    if versionPattern == 'trunk':
      versions = [ ( 'trunk', 'trunk' ) ]
    else:
      l = versionPattern.split( ':' )
      if len( l ) == 1:
        if fnmatchcase( 'trunk', versionPattern ):
          versions = [ ( 'trunk', 'trunk' ) ]
        else:
          versions = []
        for branch in brainvisaBranchesPerComponent.get( component, [] ):
          if fnmatchcase( branch, versionPattern ):
            versions.append( ( 'branch', 'branches/' + branch ) )
        for tag in brainvisaTagsPerComponent.get( component, [] ):
          if fnmatchcase( tag, versionPattern ):
            versions.append( ( 'tag', 'tags/' + tag  ) )
      elif len( l ) == 2:
        try:
          index = int( l[1] )
        except ValueError:
          raise SyntaxError()
        if l[0] == 'branch':
          try:
            versions = [ ( 'branch', 'branches/' + brainvisaBranchesPerComponent.get( component, [] )[ index ] ) ]
          except IndexError:
            versions = []
        elif l[0] == 'tag':
          try:
            versions = [ ( 'tag', 'tags/' + brainvisaTagsPerComponent.get( component, [] )[ index ] ) ]
          except IndexError:
            versions = []
        else:
          raise SyntaxError() 
      else:
        raise SyntaxError()
    return [ ( component, i[0],brainvisaURLPerComponent[ component ] + '/' + i[1] ) for i in versions ]


  def svncommand( self, *svnargs ):
    cmd = [ 'svn' ]
    if self.username:
      cmd += [ ' --username', self.username ]
    cmd.extend( svnargs )
    system( *cmd )



  def updateExternals( self, update=True ):
    externalsFileName = os.path.join( self.directory, 'bv_maker.externals' )
    externalsFile = open( externalsFileName, 'w' )
    self.clients = {}
    hasBrainvisacmake = False
    
    for url, component_version in self.componentVersionPerURL.iteritems():
      component, version = component_version
      self.clients.setdefault( version, {} ).setdefault( brainvisaProjectPerComponent.get( component ), [] ).append( url )
      if component == 'brainvisa-cmake':
        hasBrainvisacmake = True
    if not hasBrainvisacmake:
      tags = brainvisaTagsPerComponent.get( 'brainvisa-cmake' )
      if tags:
        version = 'tag'
        versionPath = 'tags/' + tags[ -1 ]
      else:
        branches = brainvisaBranchesPerComponent.get( 'brainvisa-cmake' )
        if branches:
          version = 'branch'
          versionPath = 'branches/' + branches[ -1 ]
        else:
          version = 'trunk'
          versionPath = 'trunk'
      url = BRAINVISA_SVN_URL + '/' + 'development/brainvisa-cmake/' + versionPath
      self.clients.setdefault( version, {} )[ 'brainvisa-cmake' ] = [ url ]
      
    currentProject = None
    for version, content in self.clients.iteritems():
      if version:
        print >> externalsFile, '#', version, 'version'
      else:
        print >> externalsFile, '# Directories'
      for project, urls in content.iteritems():
        for url in urls:
          print >> externalsFile, url[ len( BRAINVISA_SVN_URL ) + 1: ], url
        print >> externalsFile
    for source, dest in self.otherComponentsDirectory:
      print >> externalsFile, dest, SVN_URL + '/' + source
    externalsFile.close()

    self.svncommand( 'propset', 'svn:externals', '--file', externalsFileName, self.directory )
    self.svncommand( 'commit', '-m', '', self.directory )
    if update:
      self.svncommand( 'update', self.directory )


  def updateCMake( self ):
    cmakeFile = os.path.join( self.directory, 'bv_maker.cmake' )
    out = open( cmakeFile, 'w' )
    components = set()
    projects = set()
    for url, component_version in self.componentVersionPerURL.iteritems():
      component, version = component_version
      components.add( component )
      if component:
        projects.add( brainvisaProjectPerComponent[ component ] )
        self.clients.setdefault( version, {} ).setdefault( brainvisaProjectPerComponent.get( component ), [] ).append( url )
        print >> out, 'set( BRAINVISA_SOURCES_' + component + ' "' + os.path.join( self.directory, *url[ len( BRAINVISA_SVN_URL ) + 1: ].split( '/' ) ) + '" CACHE STRING "Sources directory for component ' + component + '" FORCE )'
        #print >> out, 'set( BRAINVISA_SOURCES_' + component + ' "' + os.path.join( self.directory, *url[ len( BRAINVISA_SVN_URL ) + 1: ].split( '/' ) ) + '" CACHE STRING "Sources directory for component ' + component + '" )'
    # Order of projects and components is important
    sortedProjects = [ p for p in brainvisaProjects if p in projects ]
    sortedComponents = []
    for project in sortedProjects:
      for component in brainvisaComponentsPerProject[ project ]:
        if component in components:
          sortedComponents.append( component )
    print >> out, 'set( BRAINVISA_PROJECTS', ' '.join( sortedProjects ),'CACHE STRING "BrainVISA Projects list" FORCE )'
    print >> out, 'set( _BRAINVISA_PROJECTS', ' '.join( sortedProjects ),'CACHE STRING "BrainVISA Projects list" FORCE )'
    print >> out, 'set( BRAINVISA_COMPONENTS', ' '.join( sortedComponents ),'CACHE STRING "BrainVISA components list" FORCE )'
    print >> out, 'set( _BRAINVISA_COMPONENTS', ' '.join( sortedComponents ),'CACHE STRING "BrainVISA components list" FORCE )'
    print >> out, 'set( BRAINVISA_OTHER_SOURCE_DIRECTORIES "' + ';'.join( (i[1] for i in self.otherComponentsDirectory) ) + '" CACHE STRING "Directories that may contain source for BrainVISA component" FORCE )'
    print >> out, 'set( BRAINVISA_SOURCES "' + self.directory + '" CACHE STRING "BrainVISA source directories" FORCE )'
    #print >> out, 'set( BRAINVISA_PROJECTS', ' '.join( sortedProjects ),'CACHE STRING "BrainVISA Projects list" )'
    #print >> out, 'set( _BRAINVISA_PROJECTS', ' '.join( sortedProjects ),'CACHE STRING "BrainVISA Projects list" )'
    #print >> out, 'set( BRAINVISA_COMPONENTS', ' '.join( sortedComponents ),'CACHE STRING "BrainVISA components list" )'
    #print >> out, 'set( _BRAINVISA_COMPONENTS', ' '.join( sortedComponents ),'CACHE STRING "BrainVISA components list" )'
    #print >> out, 'set( BRAINVISA_OTHER_SOURCE_DIRECTORIES "' + ';'.join( (i[1] for i in self.otherComponentsDirectory) ) + '" CACHE STRING "Directories that may contain source for BrainVISA component" )'
    #print >> out, 'set( BRAINVISA_SOURCES "' + self.directory + '" CACHE STRING "BrainVISA source directories" )'

    cmakeLists = os.path.join( self.directory, 'CMakeLists.txt' )
    if not os.path.exists( cmakeLists ):
      out = open( cmakeLists, 'w' )
      print >> out, '''
cmake_minimum_required( VERSION 2.6 )
set( CMAKE_PREFIX_PATH "${CMAKE_BINARY_DIR}" ${CMAKE_PREFIX_PATH} )
find_package( brainvisa-cmake NO_POLICY_SCOPE )
include( "${brainvisa-cmake_DIR}/brainvisa-compilation.cmake" )
'''



class BuildDirectory( object ):
  _validOptions = set( ( 'source', 'build_type', 'make_options' ) )
  
  def __init__( self, directory ):
    self.directory = os.path.normpath( os.path.abspath( directory ) )
    self.rules = []
    self.source = None
    self.build_type = ''
    self.make_options = ''
  
  def addRule( self, line ):
    i = line.find( '=' )
    if i > 0:
      option = line[ :i ].strip()
      value = line[ i+1: ].strip()
      if option not in self._validOptions:
        raise SyntaxError()
      setattr( self, option, value )
  
  
  def process( self, commands ):
    print '[ build', self.directory, ']'
    cmake = 'cmake' in commands
    make = 'make' in commands
    if self.source is None:
      raise ValueError( 'No source given for build directory "%s"' % self.directory )
    self.source = environmentVariablesSubstitution( self.source )
    cmakeFile = os.path.join( self.source, 'bv_maker.cmake' )
    if not os.path.exists( cmakeFile ):
      raise ValueError( 'Source directory "%s" does not exists or does not contain "bv_maker.cmake"' % self.source )
    if not os.path.exists( self.directory ):
      os.makedirs( self.directory )
      cmake = cmake or make
    if cmake:
      path = os.path.join( self.source, 'development', 'brainvisa-cmake' )
      source_bvcmake = glob.glob( os.path.join( path, 'tags', '*' ) )
      if source_bvcmake:
        source_bvcmake = source_bvcmake[0]
      else:
        source_bvcmake = glob.glob( os.path.join( path, 'branches', '*' ) )
        if source_bvcmake:
          source_bvcmake = source_bvcmake[0]
        else:
          source_bvcmake = os.path.join( path, 'trunk' )
      build_bvcmake = os.path.join( self.directory, 'build_files', 'brainvisa-cmake' )
      if not os.path.exists( build_bvcmake ):
        os.makedirs( build_bvcmake )
      system( 'cmake', '-DCMAKE_INSTALL_PREFIX:PATH=' + self.directory, source_bvcmake, cwd=build_bvcmake )
      system( 'make', 'install', cwd=build_bvcmake )
      system( 'cmake', '-DCMAKE_BUILD_TYPE:STRING=' + self.build_type, '-C', cmakeFile, self.source, cwd = self.directory )
    if make:
      system( cwd=self.directory, *( ['make'] + self.make_options.split() ) )

  

usage = '''%prog [svn] [cmake] [make]

This command enables to manage source retrieval, configuration and compilation of BrainVISA projects.

In order to work, the commands svn and svnadmin must be installed on your system. On some Linux systems they are in two separate packages (e.g. subversion and subversion-tools).'''
parser = OptionParser(usage=usage)
parser.add_option( '--username', dest='username',
                   help='specify user login to use with the svn server',
                   metavar='USERNAME', default='' )
parser.add_option( '-v', '--verbose', dest='verbose', action='store_true',
                   help='show as much information as possible' )
(options, args) = parser.parse_args()
commands = set( args )
bad_commands = commands.difference( ( 'svn', 'cmake', 'make' ) )
if bad_commands:
  raise ValueError( 'Bad command(s): %s' % ', '.join( bad_commands ) )
if not commands:
  commands = set( ('svn', 'make') )


    
# Read config file
configFile = os.path.join( os.environ[ 'HOME' ], '.brainvisa', 'bv_maker.cfg' )
packages = []
lineCount = 0
currentDirectoryObject = None
directoryObjects = []
for line in open( configFile ):
  lineCount += 1
  line = line.strip()
  if not line or line[0] == '#' or line.startswith( '//' ): continue
  try:
    if line[0] == '[':
      if line[-1] != ']': raise SyntaxError()
      l = line[1:-1].split( None, 1 )
      if len( l ) != 2:
        raise SyntaxError()
      if l[ 0 ] == 'source':
        currentDirectoryObject = SourceDirectory( environmentVariablesSubstitution( l[ 1 ].strip() ), username=options.username )
        directoryObjects.append( currentDirectoryObject )
      elif l[ 0 ] == 'build':
        currentDirectoryObject = BuildDirectory( environmentVariablesSubstitution( l[ 1 ].strip() ) )
        directoryObjects.append( currentDirectoryObject )
      else:
        raise SyntaxError()
    else:
      if currentDirectoryObject is None: raise SyntaxError()
      if options.verbose:
        print '  processing line:', repr( line )
      currentDirectoryObject.addRule( line )
  except SyntaxError:
    raise SyntaxError( 'Syntax error in ' + repr( configFile ) + ' on line ' + str( lineCount ) )
for d in directoryObjects:
  d.process( commands )
