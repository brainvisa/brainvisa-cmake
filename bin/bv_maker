#! /usr/bin/env python
# -*- coding: utf-8 -*-

from __future__ import absolute_import, division
from __future__ import print_function, unicode_literals

import codecs
import io
import locale
import multiprocessing  # for cpu_count()
import os
import sys
import traceback

import six


# -----------------------------------------------------------------------------
# Make sure that sys.path is set correctly before importing our own modules.
# -----------------------------------------------------------------------------
if os.path.exists(sys.argv[0]):
    this_script = sys.argv[0]
else:
    this_script = None
    for p in os.environ.get('PATH', '').split(os.pathsep) + [os.curdir]:
        s = os.path.join(p, sys.argv[0])
        if os.path.exists(s):
            this_script = s
            break
if this_script:
    this_script = os.path.abspath(this_script)
    python_modules = os.path.join(
        os.path.dirname(os.path.dirname(this_script)), 'python')
    if os.path.isdir(python_modules):
        sys.path.insert(0, python_modules)
# -----------------------------------------------------------------------------


from brainvisa.maker.build import check_ld_library_path_error
import brainvisa.maker.commands
import brainvisa.maker.configuration
from brainvisa.maker.version_number import version_format_short


ASCII_SUBSTITUTIONS = {
    ord('┌'): '/',
    ord('─'): '-',
    ord('│'): '|',
    ord('✓'): 'v',
    ord('✗'): 'X',
}


def substitute_ascii_error_handler(error):
    """Unicode error handler that replaces a few characters with ASCII.

    Characters not in ASCII_SUBSTITUTIONS are handled by the 'replace' error
    handler (i.e. replaced by '?').
    """
    if isinstance(error, UnicodeEncodeError):
        unencodable = error.object[error.start:error.end]
        substitute = unencodable.translate(ASCII_SUBSTITUTIONS)
        replaced_substitute = substitute.encode(error.encoding, 'replace')
        if six.PY2:
            return (replaced_substitute.decode(error.encoding), error.end)
        return (replaced_substitute, error.end)
    else:
        raise error


codecs.register_error('substitute_ascii', substitute_ascii_error_handler)


def reconfigure_stdout():
    """Reconfigure stdout so it does not crash on foreign Unicode characters.

    Also enable line-buffering, so that the output from print() and
    subprocesses will be interspersed correctly.
    """
    # Python 3.7 and later
    if hasattr(sys.stdout, 'reconfigure'):
        sys.stdout.reconfigure(errors='substitute_ascii', line_buffering=True)
        return

    try:
        fileno = sys.stdout.fileno()
    except (AttributeError, IOError):
        fileno = None

    # Under Python 2 many libraries (e.g. optparse) will try to write
    # strings of type 'str' to stdout, so we need to replace it with an
    # object that handles both unicode and str.
    if six.PY2:
        linebuf_stdout = sys.stdout
        if fileno is not None:
            linebuf_stdout = os.fdopen(fileno, 'w', 1)
        encoding = getattr(sys.stdout, 'encoding', None)
        if encoding is None:
            encoding = locale.getpreferredencoding()
        new_stdout = codecs.getwriter(encoding)(
            linebuf_stdout, errors='substitute_ascii')
    else:
        # Python 3.0 to 3.6
        new_stdout = io.open(fileno, mode='wt', buffering=1,
                             encoding=sys.stdout.encoding,
                             errors='substitute_ascii',
                             closefd=False)
    sys.stdout.flush()
    sys.stdout = new_stdout


reconfigure_stdout()


def display_failure_summary(configuration):
    sections = [('sourcesDirectories', ['sources']),
                ('buildDirectories', ['configure', 'build', 'doc', 'testref',
                                      'test']),
                ('packageDirectories', ['pack', 'install_pack', 'testref_pack',
                                        'test_pack']),
                ('publicationDirectories', ['publish_pack']),
                ]
    global_failed = False
    status_map = {'not run': '',
                  'succeeded': 'OK         ',
                  'failed': 'FAILED     ',
                  'unmet dependency': 'UNMET DEP  ',
                  'interrupted': 'INTERRUPTED'}
    sys.stdout.flush()
    sys.stderr.flush()
    messages = ['\nbv_maker summary:']
    print(messages[0])
    #log_file = None
    #if configuration.general_section \
            #and configuration.general_section.global_status_file:
        #log_file = configuration.general_section.global_status_file
        #machine = gethostname()
        #osname = global_installer_variables()['os']
    first_start = None
    last_stop = None
    for section_name, steps in sections:
        for section in getattr(configuration, section_name).values():
            for step in steps:
                status = status_map[section.get_status(step)]
                if status != '':
                    message = '%s step %s: %s' % (status, step, 
                                                  section.directory)
                    start = section.start_time.get(step)
                    if start:
                        if first_start is None:
                            first_start = start
                        message += ', started: %04d/%02d/%02d %02d:%02d' \
                            % start[:5]
                    stop = section.stop_time.get(step)
                    if stop:
                        last_stop = stop
                        message += ', stopped: %04d/%02d/%02d %02d:%02d' \
                            % stop[:5]
                    messages.append(message)
                    print(message)
                    if section.has_failed(step):
                        global_failed = True
    if global_failed:
        status = 'There were errors.'
        print(status)
    else:
        status = 'All went good.'
        print(status)
    return global_failed

# ---

# export cpu_count() as NCPU env variable so that it can be used in conf file
# for env replacements
try:
    os.environ['NCPU'] = str(multiprocessing.cpu_count())
except NotImplementedError:
    # multiprocessing.cpu_count can raise NotImplementedError
    os.environ['NCPU'] = '1'

check_ld_library_path_error(fatal=False)


default_commands = ['info', 'sources', 'configure', 'build', 'doc', 'test',
                    'pack', 'install_pack', 'test_pack']
options_by_command = {None: []}
command = None
for i in sys.argv[1:]:
    if i in brainvisa.maker.commands.COMMANDS:
        command = i
        if command in options_by_command:
            raise ValueError('Command %s used twice' % command)
        options_by_command[command] = []
    else:
        options_by_command[command].append(i)

# Initialize global configuration
configuration = brainvisa.maker.configuration.GlobalConfiguration(options_by_command[None])

# Parse commands options and prepare them for processing in the correct order
todo = []
if len(options_by_command) == 1:
    # No command selected => do all default commands
    for i in default_commands:
        options_by_command[i] = ['--only-if-default']

log_something = False
# Ordered command list
for command in ['info', 'status', 'sources', 'configure', 'build',
                'doc', 'test', 'testref', 'pack', 'install_pack', 'test_pack',
                'testref_pack', 'publish_pack']:
    if command in options_by_command:
        command_class = brainvisa.maker.commands.COMMANDS[command]
        todo.append(
            command_class(options_by_command[command], configuration))
        if command not in ('info', 'status') \
                and '-h' not in options_by_command[command] \
                and '--help' not in options_by_command[command]:
            log_something = True

failed = False
# Execute selected commands
try:
    for f in todo:
        f()
except KeyboardInterrupt:
    traceback.print_exc()
    failed = True

failed |= display_failure_summary(configuration)

if failed:
    sys.exit(1)
