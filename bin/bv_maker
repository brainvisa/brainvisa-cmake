#! /usr/bin/env python2
# -*- coding: utf-8 -*-

#  This software and supporting documentation are distributed by
#      Institut Federatif de Recherche 49
#      CEA/NeuroSpin, Batiment 145,
#      91191 Gif-sur-Yvette cedex
#      France
#
# This software is governed by the CeCILL-B license under
# French law and abiding by the rules of distribution of free software.
# You can  use, modify and/or redistribute the software under the
# terms of the CeCILL-B license as circulated by CEA, CNRS
# and INRIA at the following URL "http://www.cecill.info".
#
# As a counterpart to the access to the source code and  rights to copy,
# modify and redistribute granted by the license, users are provided only
# with a limited warranty  and the software's author,  the holder of the
# economic rights,  and the successive licensors  have only  limited
# liability.
#
# In this respect, the user's attention is drawn to the risks associated
# with loading,  using,  modifying and/or developing or reproducing the
# software by the user in light of its specific status of free software,
# that may mean  that it is complicated to manipulate,  and  that  also
# therefore means  that it is reserved for developers  and  experienced
# professionals having in-depth computer knowledge. Users are therefore
# encouraged to load and test the software's suitability as regards their
# requirements in conditions enabling the security of their systems and/or
# data to be ensured and,  more generally, to use and operate it in the
# same conditions as regards security.
#
# The fact that you are presently reading this means that you have had
# knowledge of the CeCILL-B license and that you accept its terms.

from __future__ import print_function
import sys
import os
import re
import pprint
import subprocess
import glob
import shutil
import json
from optparse import OptionParser
from fnmatch import fnmatchcase
import tempfile
import distutils.spawn
import platform
import shlex
try:
    # compatibility for python3
    import six
except ImportError:
    # six module not here, assume python2
    class six(object):
       @staticmethod
       def iteritems(obj, *args, **kwargs):
          return obj.iteritems(*args, **kwargs)

# Ugly hack to backport subprocess.check_ouput method on python < 2.7
# TODO: remove this once BrainVISA is only compatible with python >= 2.7
if "check_output" not in dir(subprocess):  # duck punch it in!
    def f(*popenargs, **kwargs):
        if 'stdout' in kwargs:
            raise ValueError(
                'stdout argument not allowed, it will be overridden.')
        process = subprocess.Popen(stdout=subprocess.PIPE, *popenargs,
                                   **kwargs)
        output, unused_err = process.communicate()
        retcode = process.poll()
        if retcode:
            cmd = kwargs.get("args")
            if cmd is None:
                cmd = popenargs[0]
            raise subprocess.CalledProcessError(retcode, cmd)
        return output
    subprocess.check_output = f

if os.path.exists(sys.argv[0]):
    this_script = sys.argv[0]
else:
    this_script = None
    for p in os.environ.get('PATH', '').split(os.pathsep) + [os.curdir]:
        s = os.path.join(p, sys.argv[0])
        if os.path.exists(s):
            this_script = s
            break
if this_script:
    this_script = os.path.normpath(os.path.abspath(this_script))
    python_modules = os.path.join(
        os.path.dirname(os.path.dirname(this_script)), 'python')
    if os.path.isdir(python_modules):
        sys.path.insert(0, python_modules)

import brainvisa.maker.components_definition
import brainvisa.maker.brainvisa_projects as brainvisa_projects

from brainvisa.maker.version_number import version_format_short


def system(*args, **kwargs):
    print(' '.join(args))
    popen = subprocess.Popen(args, **kwargs)
    popen.communicate()
    if popen.returncode != 0:
        txt = 'Command failed: %s' % ' '.join((repr(i) for i in args))
        if 'cwd' in kwargs:
            txt = '%s\nFrom directory: %s' % (txt, kwargs['cwd'])
        raise OSError(txt)


def cmake_path(path):
    if sys.platform == 'win32':
        return path.replace('\\', '/')
    else:
        return path


def copy_brainvisa_cmake(installDir):
    global this_script
    sourceDir = os.path.dirname(os.path.dirname(this_script))
    samefile = getattr(os.path, 'samefile', None)
    if samefile:
        samefile = samefile(sourceDir, installDir)
    else:
        samefile = sourceDir == installDir
    if samefile:
        return
    import brainvisa.maker
    for f in open(os.path.join(os.path.dirname(brainvisa.maker.__file__),
                               'installed_files.txt')):
        p, f = os.path.split(f.strip())
        d = os.path.join(installDir, p)
        if not os.path.exists(d):
            os.makedirs(d)
        shutil.copy(os.path.join(sourceDir, p, f), d)


def environmentVariablesSubstitution(path):
    result = path
    r = re.compile(r'\$([A-Za-z0-9_]*)')
    offset = 0
    for m in r.finditer(path):
        variableContent = os.environ.get(m.group(1))
        if variableContent is not None:
            start, end = m.span()
            start += offset
            end += offset
            offset += len(variableContent) - end + start
            result = result[:start] + variableContent + result[end:]
    return os.path.normpath(os.path.realpath(os.path.abspath(result)))


class GlobalConfiguration(object):

    def __init__(self, argv):
        usage = '''%prog [options] [ command [command options] ]...

This program is for the management of source retrieval, configuration and compilation of BrainVISA projects.

In order to work, the commands svn and svnadmin must be installed on your system. On some Linux systems they are in two separate packages (e.g. subversion and subversion-tools).

Commands:

* info: Just output info about configured components
* sources: Create or updated selected sources directories from Subversion repository.
* configure: Create and configure selected build directories with CMake.
* build: compile all selected build directories.
* doc: Generate documentation (sphinx, doxygen, docbook, epydoc)
* test: Execute tests using ctest.
* pack: Generate binary packages
* install_pack: install binary packages
* test_pack: run tests in installed binary packages

To get help for a specific command, use -h option of the command. Example: "%prog build -h".

To get help on how to configure and write a bv_maker configuration file, see:

http://brainvisa.info/brainvisa-cmake/compile_existing.html

config file syntax:

http://brainvisa.info/brainvisa-cmake/configuration.html

and more generally:

http://brainvisa.info/brainvisa-cmake/
'''
        defaultConfigurationFile = os.path.join(
            os.environ['HOME'], '.brainvisa', 'bv_maker.cfg')
        parser = OptionParser(usage=usage)
        parser.add_option('-d', '--directory', dest='directories',
                          help='Restrict actions to a selected directory. May be used several times to process several directories.',
                          metavar='DIR', action='append', default=[])
        parser.add_option('-c', '--config', dest='configuration_file',
                          help='specify configuration file. Default ="' +
                          defaultConfigurationFile + '"',
                          metavar='CONFIG', default=None)
        parser.add_option('-s', '--sources', dest='sources_directories',
                          help='directory containing sources',
                          metavar='DIR', action='append', default=[])
        parser.add_option('-b', '--build', dest='build_directory',
                          help='build directory',
                          metavar='DIR', default=None)
        parser.add_option('--username', dest='username',
                          help='specify user login to use with the svn server',
                          metavar='USERNAME', default='')
        parser.add_option(
            '-v', '--verbose', dest='verbose', action='store_true',
            help='show as much information as possible')

        (options, args) = parser.parse_args(argv)
        if args:
            raise ValueError('Invalid option: %s' % args[0])
        packages = []
        lineCount = 0
        currentDirectoryObject = None
        self.sourcesDirectories = {}
        self.buildDirectories = {}
        self.packageDirectories = {}

        directories = [os.path.normpath(os.path.realpath(os.path.abspath(d)))
                       for d in options.directories]
        self.directories = directories

        for i in ('configuration_file', 'username', 'verbose'):
            setattr(self, i, getattr(options, i))

        if options.build_directory:
            if not options.configuration_file:
                cf = os.path.join(options.build_directory, 'bv_maker.cfg')
                if os.path.exists(cf):
                    options.configuration_file = cf
                else:
                    options.configuration_file = defaultConfigurationFile
            os.environ['BV_MAKER_BUILD'] = options.build_directory
            reload(brainvisa.maker.components_definition)
            reload(brainvisa_projects)

            bd = BuildDirectory(
                environmentVariablesSubstitution(options.build_directory),
                self)
            self.buildDirectories[bd.directory] = bd
            for sd in options.sources_directories:
                if os.path.exists(os.path.join(sd, 'project_info.cmake')) \
                    or glob.glob(os.path.join(sd, 'python', '*', 'info.py')) \
                    or glob.glob(os.path.join(sd, '*', 'info.py')):
                    bd.addConfigurationLine('directory ' + sd)
                else:
                    bd.addConfigurationLine('brainvisa all * ' + sd)
        elif not options.configuration_file:
            options.configuration_file = defaultConfigurationFile

        if options.configuration_file:
            # Read configuration file
            for line in open(options.configuration_file):
                lineCount += 1
                line = line.strip()
                # skip comments
                if not line or line[0] == '#' or line.startswith('//'):
                    continue
                try:
                    if line[0] == '[':
                        if line[-1] != ']':
                            raise SyntaxError()
                        l = line[1:-1].split(None, 1)
                        if len(l) != 2:
                            raise SyntaxError()
                        if l[0] == 'source':
                            currentDirectoryObject = SourceDirectory(
                                environmentVariablesSubstitution(l[1].strip()), self)
                            self.sourcesDirectories[
                                currentDirectoryObject.directory] = currentDirectoryObject
                        elif l[0] == 'build':
                            currentDirectoryObject = BuildDirectory(
                                environmentVariablesSubstitution(l[1].strip()), self)
                            self.buildDirectories[
                                currentDirectoryObject.directory] = currentDirectoryObject
                        elif l[0] == 'virtualenv':
                            currentDirectoryObject = VirtualenvDirectory(
                                environmentVariablesSubstitution(l[1].strip()), self)
                            self.buildDirectories[
                                currentDirectoryObject.directory] = currentDirectoryObject
                        elif l[0] == 'package':
                            currentDirectoryObject = PackageDirectory(
                                environmentVariablesSubstitution(l[1].strip()), self)
                            self.packageDirectories[
                                currentDirectoryObject.directory] = currentDirectoryObject
                        else:
                            raise SyntaxError()
                    else:
                        if currentDirectoryObject is None:
                            raise SyntaxError()
                        if self.verbose:
                            print('  processing line:', repr(line))
                        currentDirectoryObject.addConfigurationLine(line)
                except SyntaxError as e:
                    msg = e.message
                    if msg == '':
                        msg = 'Syntax error'
                    raise SyntaxError('%s in ' % msg + repr(
                        options.configuration_file) + ' on line ' + str(lineCount))

        # store options and args
        self.options = options
        self.args = args


class InfoCommand(object):

    def __init__(self, argv, configuration):
        usage = '''%prog [global options] info [options]

    Display information about configuration, sources directories and build directories.'''
        parser = OptionParser(usage=usage)
        parser.add_option('--only-if-default', dest='in_config',
                          action='store_true',
                          default=False,
                          help='only perform this step if it is a default '
                          'step, or specified in the "default_steps" option '
                          'of bv_maker.cfg config file. Default steps are '
                          'normally "sources" for source sections, and '
                          '"configure build" for build sections')
        (options, args) = parser.parse_args(argv)
        if args:
            raise ValueError('Invalid option: %s' % args[0])
        self.options = options
        self.args = args

    def __call__(self):
        print('Configuration file:', configuration.configuration_file)
        for d, o in six.iteritems(configuration.sourcesDirectories):
            if not self.options.in_config or 'info' in o.default_steps:
                o.info()
        for d, o in six.iteritems(configuration.buildDirectories):
            if not self.options.in_config or 'info' in o.default_steps:
                o.info()


class SourcesCommand(object):

    def __init__(self, argv, configuration):
        usage = '''%prog [global options] sources [options]

    Create or updated selected sources directories from Subversion repository.'''
        parser = OptionParser(usage=usage)
        parser.add_option('--no-svn', dest='svn', action='store_false',
                          default=True,
                          help='don\'t update svn sources')
        parser.add_option('--no-git', dest='git', action='store_false',
                          default=True,
                          help='don\'t update git sources')
        parser.add_option('--only-if-default', dest='in_config',
                          action='store_true',
                          default=False,
                          help='only perform this step if it is a default '
                          'step, or specified in the "default_steps" option '
                          'of bv_maker.cfg config file. Default steps are '
                          'normally "sources" for source sections, and '
                          '"configure build" for build sections')
        (options, args) = parser.parse_args(argv)
        if args:
            raise ValueError('Invalid option: %s' % args[0])
        self.options = options
        self.args = args

    def __call__(self):
        for d, o in six.iteritems(configuration.sourcesDirectories):
            if not configuration.directories or d in configuration.directories:
                if not self.options.in_config or 'sources' in o.default_steps:
                    o.process(self.options, self.args)
            elif configuration.verbose:
                print('Skipping ', d,
                      'because it is not in the selected directories.')


class ConfigureCommand(object):

    def __init__(self, argv, configuration):
        usage = '''%prog [global options] configure [options]

    Create or updated selected build directories.'''
        parser = OptionParser(usage=usage)
        parser.add_option('-c', '--clean', dest='clean', action='store_true',
                          default=False,
                          help='clean build tree (using bv_clean_build_tree '
                          '-d) before configuring')
        parser.add_option('--only-if-default', dest='in_config',
                          action='store_true',
                          default=False,
                          help='only perform this step if it is a default '
                          'step, or specified in the "default_steps" option '
                          'of bv_maker.cfg config file. Default steps are '
                          'normally "sources" for source sections, and '
                          '"configure build" for build sections')
        (options, args) = parser.parse_args(argv)
        if args:
            raise ValueError('Invalid option: %s' % args[0])
        self.options = options
        self.args = args

    def __call__(self):
        for d, o in six.iteritems(configuration.buildDirectories):
            if not configuration.directories or d in configuration.directories:
                if not self.options.in_config \
                        or 'configure' in o.default_steps:
                    o.configure(self.options, self.args)
            elif configuration.verbose:
                print('Skipping ', d,
                      'because it is not in the selected directories.')


class BuildCommand(object):

    def __init__(self, argv, configuration):
        usage = '''%prog [global options] configure [options]

    Compile selected build directories.'''
        parser = OptionParser(usage=usage)
        parser.add_option('-c', '--clean', dest='clean', action='store_true',
                          default=False,
                          help='clean build tree (using '
                          'bv_clean_build_tree -b) before building')
        parser.add_option('--only-if-default', dest='in_config',
                          action='store_true',
                          default=False,
                          help='only perform this step if it is a default '
                          'step, or specified in the "default_steps" option '
                          'of bv_maker.cfg config file. Default steps are '
                          'normally "sources" for source sections, and '
                          '"configure build" for build sections')
        (options, args) = parser.parse_args(argv)
        if args:
            raise ValueError('Invalid option: %s' % args[0])
        self.options = options
        self.args = args

    def __call__(self):
        for d, o in six.iteritems(configuration.buildDirectories):
            if not configuration.directories or d in configuration.directories:
                if not self.options.in_config or 'build' in o.default_steps:
                    o.build(self.options, self.args)
            elif configuration.verbose:
                print('Skipping ', d,
                      'because it is not in the selected directories.')


class DocCommand(object):

    def __init__(self, argv, configuration):
        usage = '''%prog [global options] doc [options]

    Generate documentation (docbook, epydoc, doxygen).'''
        parser = OptionParser(usage=usage)
        parser.add_option('--only-if-default', dest='in_config',
                          action='store_true',
                          default=False,
                          help='only perform this step if it is a default '
                          'step, or specified in the "default_steps" option '
                          'of bv_maker.cfg config file. Default steps are '
                          'normally "sources" for source sections, and '
                          '"configure build" for build sections')
        (options, args) = parser.parse_args(argv)
        if args:
            raise ValueError('Invalid option: %s' % args[0])
        self.options = options
        self.args = args

    def __call__(self):
        for d, o in six.iteritems(configuration.buildDirectories):
            if not configuration.directories or d in configuration.directories:
                if not self.options.in_config or 'doc' in o.default_steps:
                    o.doc()
            elif configuration.verbose:
                print('Skipping ', d,
                      'because it is not in the selected directories.')


class TestCommand(object):

    def __init__(self, argv, configuration):
        usage = '''%prog [global options] test

    Executes ctest.'''
        parser = OptionParser(usage=usage)
        parser.add_option('--only-if-default', dest='in_config',
                          action='store_true',
                          default=False,
                          help='only perform this step if it is a default '
                          'step, or specified in the "default_steps" option '
                          'of bv_maker.cfg config file. Default steps are '
                          'normally "sources" for source sections, and '
                          '"configure build" for build sections')
        (options, args) = parser.parse_args(argv)
        if args:
            raise ValueError('Invalid option: %s' % args[0])
        self.options = options
        self.args = args

    def __call__(self):
        for d, o in six.iteritems(configuration.buildDirectories):
            if not configuration.directories or d in configuration.directories:
                if not self.options.in_config or 'test' in o.default_steps:
                    o.test()
            elif configuration.verbose:
                print('Skipping ', d,
                      'because it is not in the selected directories.')


class PackCommand(object):

    def __init__(self, argv, configuration):
        usage = '''%prog [global options] pack [options]

    Make installer package for the selected build directory.'''
        parser = OptionParser(usage=usage)
        parser.add_option('--only-if-default', dest='in_config',
                          action='store_true',
                          default=False,
                          help='only perform this step if it is a default '
                          'step, or specified in the "default_steps" option '
                          'of bv_maker.cfg config file. Default steps are '
                          'normally "sources" for source sections, '
                          '"configure build" for build sections.')
        (options, args) = parser.parse_args(argv)
        if args:
            raise ValueError('Invalid option: %s' % args[0])
        self.options = options
        self.args = args

    def __call__(self):
        for d, o in six.iteritems(configuration.packageDirectories):
            if not configuration.directories or d in configuration.directories:
                if not self.options.in_config or 'pack' in o.default_steps:
                    o.package(self.options, self.args)
            elif configuration.verbose:
                print('Skipping ', d,
                      'because it is not in the selected directories.')


class InstallPackCommand(object):

    def __init__(self, argv, configuration):
        usage = '''%prog [global options] install_pack [options]

    Install a binary package for the selected build directory.'''
        parser = OptionParser(usage=usage)
        parser.add_option('--only-if-default', dest='in_config',
                          action='store_true',
                          default=False,
                          help='only perform this step if it is a default '
                          'step, or specified in the "default_steps" option '
                          'of bv_maker.cfg config file. Default steps are '
                          'normally "sources" for source sections, '
                          '"configure build" for build sections.')
        (options, args) = parser.parse_args(argv)
        if args:
            raise ValueError('Invalid option: %s' % args[0])
        self.options = options
        self.args = args

    def __call__(self):
        for d, o in six.iteritems(configuration.packageDirectories):
            if not configuration.directories or d in configuration.directories:
                if not self.options.in_config \
                        or 'install_pack' in o.default_steps:
                    o.install_package(self.options, self.args)
            elif configuration.verbose:
                print('Skipping ', d,
                      'because it is not in the selected directories.')


class TestPackCommand(object):

    def __init__(self, argv, configuration):
        usage = '''%prog [global options] test_pack [options]

    Test in installed package for the selected build directory.'''
        parser = OptionParser(usage=usage)
        parser.add_option('--only-if-default', dest='in_config',
                          action='store_true',
                          default=False,
                          help='only perform this step if it is a default '
                          'step, or specified in the "default_steps" option '
                          'of bv_maker.cfg config file. Default steps are '
                          'normally "sources" for source sections, '
                          '"configure build" for build sections.')
        (options, args) = parser.parse_args(argv)
        if args:
            raise ValueError('Invalid option: %s' % args[0])
        self.options = options
        self.args = args

    def __call__(self):
        for d, o in six.iteritems(configuration.packageDirectories):
            if not configuration.directories or d in configuration.directories:
                if not self.options.in_config \
                        or 'test_pack' in o.default_steps:
                    o.test_package(self.options, self.args)
            elif configuration.verbose:
                print('Skipping ', d,
                      'because it is not in the selected directories.')


class SourceDirectory(object):

    _validOptions = set(('default_steps', 'revision_control'))

    def __init__(self, directory, configuration):
        self.configuration = configuration
        self.directory = os.path.normpath(os.path.abspath(directory))
        self.configurationLines = []
        self.svnComponents = []
        self.gitComponents = []
        self.default_steps = ['sources']
        self.revision_control = 'ON'
        if self.configuration.verbose:
            print('Processing source directory %s' % self.directory)

    def addConfigurationLine(self, line, virtual=False, component_version=None):
        # Supported lines in bv_maker.cfg for [ source ... ]:
        #    default_steps [info] [sources]
        #    git <url> <git_tag> [<dest_directory> [<bv_version>]]
        #    svn <url> [<dest_directory> [<bv_version>]]
        #    brainvisa <component_pattern> <version_pattern>
        #    brainvisa_exclude <component_pattern> [<version_pattern>]
        #    + soma/soma-base/trunk [<dest_directory>] [<bv_version>]]
        #    + https://svn.url [<dest_directory>] [<bv_version>]]
        #    + <component_pattern> <version_pattern>
        #    - <component_pattern> [<version_pattern>]
        i = line.find('=')
        if i > 0:
            option = line[:i].strip()
            value = line[i + 1:].strip()
            if option not in self._validOptions:
                raise SyntaxError('Invalid option: %s' % option)
            if hasattr(self, option) \
                    and type(getattr(self, option)) in (list, tuple):
                value = value.split()
            setattr(self, option, value)
        else:
            l = line.split()
            sign = l[0]
            if sign == 'git':
                if len(l) < 3 or len(l) > 5:
                    raise SyntaxError()
                sign, url, git_tag, dest_directory, bv_version = (
                    l + [None, None])[:5]
                if self.configuration.verbose:
                    print('    adding repository: git', url, git_tag)
                    print('                   in:', \
                        os.path.join(self.directory, dest_directory))
                    if component_version:
                        print('                  for: %s version %s' \
                            % component_version)
                self.gitComponents.append(
                    (component_version, url, git_tag, dest_directory, bv_version))
            else:
                if len(l) < 2 or len(l) > 4:
                    raise SyntaxError()
                sign, componentPattern, versionPattern, bv_version = (
                    l + [None, None])[:4]
                if sign == 'svn' or (sign == '+' and '/' in componentPattern):
                    if '*' in componentPattern:
                        raise SyntaxError()
                    if componentPattern.startswith('http') or componentPattern.startswith('file'):
                        url = componentPattern
                        dest_directory = versionPattern
                    else:
                        url = brainvisa_projects.SVN_URL + '/' + componentPattern
                        dest_directory = versionPattern
                        if dest_directory is None:
                            dest_directory = componentPattern
                    if dest_directory is None:
                        raise SyntaxError()
                    if self.configuration.verbose:
                        print('    adding repository: svn', url, component_version)
                        print('                   in:', \
                            os.path.join(self.directory, dest_directory))
                        if component_version:
                            print('                  for: %s version %s' \
                                % component_version)

                    self.svnComponents.append(
                        (component_version, url, dest_directory, bv_version))
                elif sign in ('brainvisa', '+'):
                    if versionPattern is None:
                        raise SyntaxError()
                    for component in brainvisa_projects.find_components(componentPattern):
                        project = brainvisa_projects.project_per_component[component]
                        for version, repo_dir in six.iteritems(brainvisa_projects.url_per_component[component]):
                            repo, dir = repo_dir
                            if fnmatchcase(version, versionPattern):
                                self.addConfigurationLine(
                                    '%s %s %s' % (repo, dir, version), virtual=True, component_version=(component, version))
                elif sign in ('-', 'brainvisa_exclude'):
                    if '/' in componentPattern:
                        raise SyntaxError()
                    else:
                        if versionPattern is None:
                            versionPattern = '*'
                        for component in brainvisa_projects.find_components(componentPattern):
                            for version, repo_dir in six.iteritems(brainvisa_projects.url_per_component[component]):
                                if fnmatchcase(version, versionPattern):
                                    # Remove unwanted svn components
                                    count = 0
                                    for component_version in [i[0] for i in self.svnComponents]:
                                        if component_version:
                                            c, v = component_version
                                            if c == component and v == version:
                                                if self.configuration.verbose:
                                                    component_version, url, dest_directory, bv_version = self.svnComponents[
                                                        count]
                                                    print('    removing repository: svn', url)
                                                    print('                     in:', os.path.join(self.directory, dest_directory))
                                                    print('                    for: %s version %s' % component_version)
                                                del self.svnComponents[count]
                                                count -= 1
                                        count += 1
                                    # Remove unwanted git components
                                    count = 0
                                    for component_version in [i[0] for i in self.gitComponents]:
                                        if component_version:
                                            c, v = component_version
                                            if c == component and v == version:
                                                if self.configuration.verbose:
                                                    component_version, url, git_tag, dest_directory, bv_version = self.gitComponents[
                                                        count]
                                                    print('    removing repository: git', url, git_tag)
                                                    print('                     in:', os.path.join(self.directory, dest_directory))
                                                    print('                    for: %s version %s' % component_version)
                                                del self.gitComponents[count]
                                                count -= 1
                                        count += 1
                else:
                    raise SyntaxError('Line cannot begin with "%s"' % sign)
        if not virtual:
            self.configurationLines.append(line)

    def process(self, options, args):
        if not os.path.exists(self.directory):
            os.makedirs(self.directory)
        clientFile = open(os.path.join(self.directory, 'bv_maker.cfg'), 'w')
        print('\n'.join(self.configurationLines), file=clientFile)

        repositoryDirectory = os.path.join(self.directory, '.repository')
        checkout = False
        use_rcs = self.revision_control.upper() in ('', 'ON')
        if use_rcs and options.svn and not os.path.exists(repositoryDirectory):
            os.makedirs(repositoryDirectory)
            # Because of a bug in svnadmin on MacOS, I cannot use an absolute name for the directory to create.
            # When I try "svnadmin create /neurospin/brainvisa/cmake_mac/", I have the following error:
            # svnadmin: '/neurospin/brainvisa/cmake_mac' is a subdirectory of an existing repository rooted at '/neurospin'
            # But it works if I do "cd /neurospin/brainvisa && vnadmin create
            # cmake_mac"
            cwd, dir = os.path.split(repositoryDirectory)
            system('svnadmin', 'create', dir, cwd=cwd)

            if len(os.path.splitdrive(repositoryDirectory)[0]) > 0:
                # This is for windows absolute pathes
                repositoryDirectory = '/' + \
                    repositoryDirectory.replace(os.path.sep, "/")

            self.svncommand(
                'checkout',  'file://' + repositoryDirectory, self.directory)
            checkout = True

        source_directories = []

        # Update SVN repositories

        current_dir = os.getcwd()
        # Go to the sources directory
        os.chdir(self.directory)
        externalsFileName = os.path.join(self.directory, 'bv_maker.externals')
        externalsFile = open(externalsFileName, 'w')
        for component_version, url, dest_directory, bv_version in set(self.svnComponents):
            print(dest_directory, url, file=externalsFile)
            source_directories.append((dest_directory, bv_version))
        externalsFile.close()
        if use_rcs and options.svn:
            self.svncommand('propset', 'svn:externals',
                            '--file', externalsFileName, self.directory)
            self.svncommand('commit', '-m', '', self.directory)
            self.svncommand('update', self.directory)
        os.chdir(current_dir)

        # update Git Repositories

        for component_version, url, git_tag, dest_directory, bv_version \
                in self.gitComponents:
            if dest_directory is None:
                dest_directory = url.rsplit('/', 1)[-1]
                if dest_directory.endswith('.git'):
                    dest_directory = dest_directory[:-4]
            dest_path = os.path.join(self.directory, dest_directory)
            if use_rcs and options.git:
                self.gitupdate(url, dest_path, git_tag)
            source_directories.append((dest_path, bv_version))

        components_sources = {}
        for dest_path, bv_version in source_directories:
            pinfo = brainvisa_projects.read_project_info(
                os.path.join(self.directory, dest_path),
                version_format=version_format_short
            )
            if pinfo:
                project, component, version, build_model = pinfo
                version = str(version)
                components_sources.setdefault(component, {})[
                    bv_version or version] = (dest_path, build_model)
            else:
                print('WARNING: directory %s will be ignored because project_info.cmake, python/*/info.py or */info.py cannot be found' % os.path.join(self.directory, dest_path))
        json.dump(components_sources, open(
            os.path.join(self.directory, 'components_sources.json'), 'w'), indent=2)

    def svncommand(self, *svnargs):
        cmd = ['svn']
        if self.configuration.username:
            cmd += [' --username', self.configuration.username]
        cmd.extend(svnargs)
        system(*cmd)

    def get_git_remotes(self, dest):
        cmd_output = str(subprocess.check_output(['git', 'remote', '-v'],
                                                   cwd=dest))
        remotes = {}
        for line in cmd_output.split('\n'):
            remotere = re.compile('^([^ ]+)[\s|\t]+([^ ]+)\s+([^ ]+)\s*$')
            m = remotere.match(line)
            if not m:
                continue
            remote, url, io = m.group(1), m.group(2), m.group(3)
            if remote not in remotes:
                if url.startswith('git@'):
                    protocol = 'git'
                    prefix, address = url.split(':')
                    prefix += ':'
                elif url.startswith('https://'):
                    protocol = 'https'
                    address = url[8:].split('/')
                    prefix = url[:8] + address[0] + '/'
                    address = '/'.join(address[1:])
                else:
                    # assume local repository
                    protocol = ''
                    prefix = ''
                    address = url
                remotes[remote] = protocol, prefix, address
        return remotes

    def gitupdate(self, src, dest, remote_ref="HEAD"):
        # Set a username in src if necessary
        if '@' not in src and self.configuration.username:
            url_head, url_tail = src.split('//', 1)
            src = '%s//%s@%s' % (
                url_head, self.configuration.username, url_tail)

        print("Updating git repository {0}".format(dest))

        # Clone repository if it does not exist yet locally
        if not os.path.exists(os.path.join(dest, '.git')):
            if os.path.isdir(dest) and os.listdir(dest):
                print('''
ERROR: directory "%s" is not empty, Git will not be able to clone into it.
This error may be due to a repository change for a component (typically
going from Subversion to Git). You must check yourself that you have nothing
to keep in this directory and delete it to make "bv_maker sources" work.'''
                       % dest)
            if self.configuration.verbose:
                print('directory %s is not a git repository => clone from git %s'
                      % (dest, src))
            os.makedirs(dest)
            retcode = subprocess.call(['git', 'init', '--quiet'], cwd=dest)
            if retcode != 0:
                print(
                    'ERROR: could not initialize git repository in {0}'.format(dest))
                return

        remotes = self.get_git_remotes(dest)
        if 'origin' in remotes:
            remote = remotes['origin']
            if src.endswith(remote[2]):
                    # user has configured manually a different protocol:
                    # respect it.
                src = remote[1] + remote[2]
        # Configure a remote for the developer's convenience
        retcode = subprocess.call(['git', 'remote', 'set-url', 'origin', src],
                                  cwd=dest, stderr=open(os.devnull, 'w'))
        if retcode != 0:
            subprocess.call(['git', 'remote', 'add', 'origin', src],
                            cwd=dest)
            # Failure is ignored deliberately (the remote is just for
            # convenience)

        # Get the SHA-1 identifiers of HEAD and refs/bv_head commits
        try:
            old_head = str(subprocess.check_output(
                ['git', 'rev-parse', '--quiet', '--verify', 'HEAD^{commit}'],
                cwd=dest))
        except subprocess.CalledProcessError:
            old_head = None
        try:
            old_bv_head = str(subprocess.check_output(
                ['git', 'rev-parse', '--quiet',
                 '--verify', 'refs/bv_head^{commit}'],
                cwd=dest))
        except subprocess.CalledProcessError:
            old_bv_head = None

        # Fetch the remotes specified in bv_maker.cfg into refs/bv_head
        remotes = self.get_git_remotes(dest)
        for remote in remotes:
            # get stderr in a separate stream since git finds it funny to print
            # normal operation messages in stderr.
            stderr_str = tempfile.NamedTemporaryFile(delete=False)
            retcode = subprocess.call(['git', 'fetch', '--quiet', '--tags',
                                       remote],
                                      cwd=dest, stderr=stderr_str)
            stderr_str.close()
            stderr_content = open(stderr_str.name).read()
            os.unlink(stderr_str.name)

            if retcode != 0:
                sys.stderr.write(stderr_content)
                print(
                    '{0}: could not fetch from git repository {1}'.format(dest, src))
            else:
                # if no error, the output is sent to stdout, not stderr.
                sys.stdout.write(stderr_content)

        retcode = subprocess.call(['git', 'fetch', '--quiet', src,
                                   "+" + remote_ref + ":refs/bv_head"],
                                  cwd=dest)
        if retcode != 0:
            print(
                '{0}: could not fetch from git repository {1}'.format(dest, src))
            return  # Abort for this repository, continue with other repositories

        # Check if we are in detached HEAD state
        retcode = subprocess.call(['git', 'symbolic-ref', '--quiet', 'HEAD'],
                                  cwd=dest, stdout=open(os.devnull, 'w'))
        detached_head = False if retcode == 0 else True

        if (not old_head) or (detached_head and old_head == old_bv_head):
            # HEAD is detached, and is the same as left by the previous
            # bv_maker run: this is "follower mode", the remote ref can be
            # checked out. This is safe to do even if there are local
            # uncommitted changes, in which case "git checkout" will error out
            # appropriately.
            retcode = subprocess.call(['git', 'checkout', '--quiet',
                                       '--detach', 'refs/bv_head', '--'],
                                      cwd=dest)
            if retcode != 0:
                print("""\
The git repository at {0} could not be updated,
please refer to the above error message.

If you have made local changes, you should keep track of them in a branch:
  git checkout -b <my_branch>
  git add ...
  git commit

Or, discard your changes and go back to following the upstream version:
  git checkout bv_head""".format(dest))
        elif not detached_head:
            # We are following a branch. Advance the branch if it has not
            # diverged from upstream. If local commits exist, that would
            # require creating a merge commit, and we do not want to do that
            # behind the back of the developer. The (fetch + merge) command
            # sequence is equivalent to "git pull --ff-only src remote_ref".
            # The merge aborts safely if there are local uncommitted changes,
            # and prints an appropriate message.
            retcode = subprocess.call(
                ['git', 'merge', '--ff-only', 'refs/bv_head'],
                cwd=dest)
            if retcode != 0:
                print("""\
Upstream changes could not be merged in {0},
please refer to the above message of "git merge".

If you do not want to develop in this repository anymore, you should
leave the branch and go back to tracking the upstream version:
  git checkout bv_head""".format(dest))
        else:
            # HEAD is detached but has been moved since last bv_maker run. The
            # user has likely checked out a tag manually, do not mess with
            # their repository.
            print("""\
The git repository at {0} will not be updated by bv_maker,
because it is detached at a commit that does not correspond to bv_head.
If you did not do this on purpose, you should go back to following upstream:
  git -C '{0}' checkout bv_head""".format(dest))

    def info(self):
        print('Source directory: "' + self.directory + '"')
        for component_version, url, dest_directory, bv_version in self.svnComponents:
            print('  %s <- svn %s' % (dest_directory, url))
            if component_version:
                component, version = component_version
                print('    component %s (%s)' % (component, version))
        for component_version, url, git_tag, dest_directory, bv_version in self.gitComponents:
            print('  %s <- git %s' % (dest_directory, url))
            if component_version:
                component, version = component_version
                print('    component %s (%s)' % (component, version))


class ComponentsConfigParser(object):

    def __init__(self, directory, configuration):
        self.configuration = configuration
        self.directory = os.path.normpath(os.path.abspath(directory))
        self.configurationLines = []
        self.projects = set()
        self.components = {}
        self._configuration_lines_processed = False

    def _process_configuration_lines(self):
        if not self._configuration_lines_processed:
            if self.configuration.verbose:
                print('Processing build directory %s' % self.directory)
            for line in self.configurationLines:
                if '=' in line:
                    continue
                first, rest = line.split(None, 1)
                if first in ('directory', '+'):
                    directory = os.path.normpath(
                        os.path.abspath(environmentVariablesSubstitution(
                            rest.strip())))
                    pinfo = brainvisa_projects.read_project_info(
                        directory,
                        version_format=version_format_short
                    )
                    if pinfo:
                        project, component, version, build_model = pinfo
                        version = str(version)
                        if self.configuration.verbose:
                            print('    adding component %s version %s from %s' % (component, version, directory))
                        self.components[component] = (
                            directory, version, version, build_model)
                    else:
                        print('WARNING: directory %s will be ignored because project_info.cmake, python/*/info.py or */info.py cannot be found' % directory)
                elif first in ('brainvisa_exclude', '-'):
                    component_def = rest.split(None, 1)
                    componentPattern, versionPattern = (
                        component_def + ['*'])[:2]
                    components \
                        = brainvisa_projects.find_components(componentPattern)
                    if len(components) == 0 \
                            and component_def[0] in self.components:
                        components = [component_def[0]]
                    for component in components:
                        dir_version = self.components.get(component)
                        if dir_version:
                            dir, selected_version, component_version, \
                               build_model = dir_version
                            if fnmatchcase(selected_version, versionPattern):
                                if self.configuration.verbose:
                                    print('    removing component %s from %s' % (component, dir))
                                del self.components[component]
                elif first == 'brainvisa' \
                        or (first
                            in brainvisa_projects.project_per_component) \
                        or (first in brainvisa_projects.components_per_group) \
                        or (first
                            in brainvisa_projects.components_per_project) \
                        or '*' in first:
                    if first == 'brainvisa':
                        l = rest.split(None, 2)
                        componentPattern, versionPattern, sourceDirectory = l
                    else:
                        l = rest.split(None, 1)
                        componentPattern = first
                        versionPattern, sourceDirectory = l
                    sourceDirectory = os.path.normpath(
                        os.path.abspath(environmentVariablesSubstitution(
                            sourceDirectory)))
                    components_sources = json.load(
                        open(os.path.join(sourceDirectory,
                                          'components_sources.json')))
                    projects_set = brainvisa_projects.ProjectsSet()
                    projects_set.add_sources_list(components_sources)
                    possible_components = set(
                        projects_set.find_components(componentPattern))
                    for component in possible_components:
                        for version, directory_model \
                                in six.iteritems(
                                    components_sources.get(component, {})):
                            if isinstance(directory_model, list):
                                directory, build_model = directory_model
                            else:
                                directory = directory_model
                                build_model = None
                            directory = os.path.join(
                                sourceDirectory, directory)
                            if fnmatchcase(version, versionPattern):
                                pinfo = brainvisa_projects.read_project_info(
                                    directory,
                                    version_format=version_format_short
                                )
                                if pinfo:
                                    project, component, component_version, \
                                        build_model = pinfo
                                    component_version = str(component_version)
                                    if self.configuration.verbose:
                                        print('    adding component %s version %s from %s' \
                                            % (component, version, directory))
                                    self.components[component] = (
                                        directory, version, component_version, build_model)
                                else:
                                    print('WARNING: directory %s will be ignored because project_info.cmake, python/*/info.py or */info.py cannot be found' % directory)
                elif first == 'pip':
                    if '=' in rest:
                        module, version = rest.split(None, 1)
                    else:
                        module = rest
                        version = None
                    installed_json = os.path.join(
                        self.directory, 'bv_maker_install.json')
                    if os.path.exists(installed_json):
                        installed = json.load(open(installed_json))
                    else:
                        installed = {}
                    pip_installed = installed.setdefault('pip', {})
                    if module not in pip_installed:
                        command = [os.path.join(
                            self.directory, 'bin', 'pip'), 'install',
                            ('%s==%s' % (module, version) if version
                             else module)]
                        print('Running:', ' '.join(command))
                        subprocess.check_call(command)
                        pip_installed[module] = version
                        json.dump(installed, open(installed_json, 'w'))
                else:
                    SyntaxError()
            projects = set(brainvisa_projects.project_per_component.get(i, i)
                           for i in self.components)
            self.projects = [i for i in brainvisa_projects.ordered_projects
                             if i in projects]
            self.projects.extend(projects - set(self.projects))
            self._configuration_lines_processed = True
            if self.configuration.verbose:
                print('Build directory %s parsing done.' % self.directory)


class BuildDirectory(ComponentsConfigParser):

    _validOptions = set(('build_type', 'make_options', 'cmake_options',
                         'packaging_thirdparty', 'default_steps',
                         'build_condition'))

    sitecustomize_content = '''import os

for i in os.listdir(os.path.dirname(__file__)):
    if i.endswith('.py') and i != '__init__.py':
        module = i[:-3]
        __import__('sitecustomize.%s' % module)
'''

    def __init__(self, directory, configuration):
        super(BuildDirectory, self).__init__(directory, configuration)
        # self.configurationDirectories = []
        self.build_type = ''
        self.make_options = ''
        self.cmake_options = ''
        self.packaging_thirdparty = ''
        self.clean_commands = True
        self.default_steps = ['configure', 'build']
        self.build_condition = None

    def addConfigurationLine(self, line):
        # Supported lines in bv_maker.cfg for [ build ... ]:
        #    default_steps [info] [configure] [build] [doc] [test]
        #    directory <directory>
        #    brainvisa <component_pattern> <version_pattern> <source_directory>
        #    brainvisa_exclude <component_pattern> [<version_pattern>]
        #    + <directory>
        #    - <component_pattern> [<version_pattern>]
        #    <component_pattern> <version_pattern> <source_directory>
        i = line.find('=')
        if i > 0:
            option = line[:i].strip()
            value = line[i + 1:].strip()
            if option not in self._validOptions:
                raise SyntaxError('Invalid option: %s' % option)
            if hasattr(self, option) \
                    and type(getattr(self, option)) in (list, tuple):
                value = value.split()
            setattr(self, option, value)
        elif line[0] == '+':
            if '*' in line:
                raise SyntaxError()
        elif line[0] == '-':
            pass
        else:
            l = line.split(None, 2)
        self.configurationLines.append(line)

    def conditional_build(self):
        '''Tells if the current build directory has actually to be built.
        If a condition option is False, it will not.
        '''
        if not self.build_condition:
            return True
        cond = True
        try:
            cond = eval(self.build_condition)
        except Exception as e:
            print('Build directory', self.directory, ': error in parsing build_condition option:', file=sys.stderr)
            print(self.build_condition, file=sys.stderr)
            print('(Condition is evaluated as python expression). Error:', sys.stderr)
            print(e, file=sys.stderr)
            raise
        return cond

    def configure(self, options, args):
        self._process_configuration_lines()
        if not self.conditional_build():
            return
        # Order of projects and components is important for dependencies
        sortedProjects = [p for p in brainvisa_projects.ordered_projects
                          if p in self.projects]
        sortedComponents = []
        components = set(self.components)
        for project in sortedProjects:
            for component \
                    in brainvisa_projects.components_per_project[project]:
                if component in components:
                    sortedComponents.append(component)
                    components.remove(component)
        sortedComponents.extend(components)

        if not os.path.exists(self.directory):
            os.makedirs(self.directory)

        if options.clean:
            my_path = os.path.dirname(__file__)
            bv_clean = os.path.join(my_path, 'bv_clean_build_tree')
            print('cleaning build tree', self.directory)
            # clean and remove empty dirs. Don't use -b option here
            # because configuration has to be done first.
            subprocess.call([sys.executable, bv_clean, '-d', self.directory])

        # Create a sitecustomize Python package that imports all modules it
        # contains during Python startup. This is mainly used to modify
        # sys.path to include pure Python components source (see module
        # brainvisa.maker.build_models.pure_python). This package is used only
        # in build directory, it is not installed in packages (to date there is
        # one exception to this in axon component, see Axon's CMakeLists.txt).
        sitecustomize_dir = os.path.join(
            self.directory, 'python', 'sitecustomize')
        if not os.path.exists(sitecustomize_dir):
            os.makedirs(sitecustomize_dir)
        open(os.path.join(sitecustomize_dir, '__init__.py'), 'w').write(
            self.sitecustomize_content)
        # Remove existing sitecustomize.py (was generated by older Axon)
        for i in glob.glob(sitecustomize_dir + '.py*'):
            os.remove(i)

        if not os.path.exists(self.directory):
            os.makedirs(self.directory)

        self.buildModelPerComponent = {}
        for component in sortedComponents:
            # find build model
            build_model = self.components[component][3]
            if build_model is None:
                build_model = brainvisa_projects.info_per_component.get(
                    component, {}).get('build_model')
            if build_model is not None:
                build_model_class = getattr(__import__(
                    'brainvisa.maker.build_models',
                    fromlist=['pure_python'], level=0),
                    build_model)
                build_model = build_model_class(
                    component, self.components[component][0], self,
                    options=options, args=args)
                self.buildModelPerComponent[component] = build_model

        cmakeFile = os.path.join(self.directory, 'bv_maker.cmake')
        out = open(cmakeFile, 'w')
        print('set( BRAINVISA_PROJECTS', ' '.join(
            sortedProjects), 'CACHE STRING "BrainVISA Projects list" FORCE )',
            file=out)
        print('set( _BRAINVISA_PROJECTS', ' '.join(
            sortedProjects), 'CACHE STRING "BrainVISA Projects list" FORCE )',
            file=out)
        print('set( BRAINVISA_COMPONENTS',
              ' '.join(sortedComponents),
              'CACHE STRING "BrainVISA components list" FORCE )',
              file=out)
        print('set( _BRAINVISA_COMPONENTS',
              ' '.join(sortedComponents),
              'CACHE STRING "BrainVISA components list" FORCE )',
              file=out)
        print(file=out)
        for component, directory_version_model in six.iteritems(self.components):
            directory, selected_version, version, build_model = directory_version_model
            if component in self.buildModelPerComponent:
                print('set( BRAINVISA_SOURCES_' + component + ' "' \
                    + cmake_path(self.directory ) + '/build_files/' \
                    + component + '_src' \
                    + '" CACHE STRING "Sources directory for component ' \
                    + component + '" FORCE )',
                    file=out)
            else:
                print('set( BRAINVISA_SOURCES_' + component + ' "' \
                    + cmake_path(directory) \
                    + '" CACHE STRING "Sources directory for component ' \
                    + component + '" FORCE )',
                    file=out)
            print('set( ' + component + '_DIR "' \
                + cmake_path(self.directory ) + '/share/' + component + \
                '-' + version + \
                '/cmake" CACHE STRING "Directory used for find_package( ' + \
                component + \
                ' )" FORCE )',
                file=out)
            print('set( ' + component + '_VERSION "' + version + '" )',
                  file=out)

        cmakeLists = os.path.join(self.directory, 'CMakeLists.txt')
        out.close()
        out = open(cmakeLists, 'w')
        print('''
cmake_minimum_required( VERSION 2.6 )
set( CMAKE_PREFIX_PATH "${CMAKE_BINARY_DIR}" ${CMAKE_PREFIX_PATH} )
find_package( brainvisa-cmake NO_POLICY_SCOPE )
include( "${brainvisa-cmake_DIR}/brainvisa-compilation.cmake" )
''', file=out)
        out.close()
        exe_suffix = ''
        if sys.platform == 'win32':
            command_base = ['cmake', '-G', 'MSYS Makefiles']
            exe_suffix = '.exe'
        else:
            command_base = ['cmake']

        command_base += self.cmake_options.split()
        command_base += ['-DCMAKE_BUILD_TYPE:STRING=' + self.build_type]
        command = command_base + [cmake_path(self.directory)]
        if self.packaging_thirdparty.upper() == 'ON':
            command += ['-DBRAINVISA_PACKAGING_THIRDPARTY:BOOL=ON']
        elif self.packaging_thirdparty.upper() == 'OFF':
            command += ['-DBRAINVISA_PACKAGING_THIRDPARTY:BOOL=OFF']

        for component, build_model \
                in six.iteritems(self.buildModelPerComponent):
            build_model.configure()

        # set bv_maker path, so that cmake finds its modules
        os.environ['PATH'] = os.path.dirname(this_script) + os.pathsep \
            + os.getenv('PATH')

        # special case: if bv-cmake is part of the build directory, run cmake
        # in 2 passes: once to reinstall bv-cmake from sources, and a second
        # time to actually configure all projects using the newly installed
        # bv-cmake.
        if 'brainvisa-cmake' in self.components:
            print('=== bootstraping brainvisa-cmake project ===')
            bvcmake_dir = os.path.join(self.directory, 'brainvisa-cmake')
            if not os.path.exists(bvcmake_dir):
                os.makedirs(bvcmake_dir)
            system(cwd=bvcmake_dir,
                   *(command_base
                     + [self.components['brainvisa-cmake'][0],
                        '-DBRAINVISA_CMAKE_BUILD_TYPE=brainvisa-cmake-only',
                        '-DCMAKE_INSTALL_PREFIX=%s' % self.directory]))
            system(cwd=bvcmake_dir, *['make', 'install'])
            print('=== now configuring all other projects ===')
            # run with this local bv-cmake environment
            command.insert(0, os.path.join(self.directory, 'bin',
                                           'bv_env_host%s' % exe_suffix))
            system(cwd=self.directory,
                   *(command
                     + ["-DBRAINVISA_CMAKE_BUILD_TYPE=no-brainvisa-cmake"]))
        else:
            # run cmake in a regular way
            system(cwd=self.directory, *command)

    def build(self, options, args):
        self._process_configuration_lines()
        if not self.conditional_build():
            return
        if options.clean:
            if self.clean_commands:
                clean_opts = ['-b']
            else:
                clean_opts = []
            my_path = os.path.dirname(__file__)
            bv_clean = os.path.join(my_path, 'bv_clean_build_tree')
            print('cleaning build tree', self.directory)
            # don't remove empty dirs here since configure may have created
            # directories which will be used during build
            subprocess.call(
                [sys.executable, bv_clean] + clean_opts + [self.directory])

        print('Building directory:', self.directory)
        system(cwd=self.directory, *(['make'] + self.make_options.split()))

    def doc(self):
        self._process_configuration_lines()
        if not self.conditional_build():
            return
        print('Building docs in directory:', self.directory)
        system(cwd=self.directory, *
               (['make'] + self.make_options.split() + ['doc']))

    def test(self):
        self._process_configuration_lines()
        if not self.conditional_build():
            return
        # get parallel jobs option if specified
        make_opts = self.make_options.split()
        options = []
        print('testing directory:', self.directory)
        system(cwd=self.directory,
               *(['ctest', '--output-on-failure'] + options))

    def info(self):
        self._process_configuration_lines()
        if not self.conditional_build():
            return
        print('Build directory: "' + self.directory + '"')
        for component, directory_version_model in six.iteritems(self.components):
            directory, selected_version, version, build_model = directory_version_model
            print('  %s (%s) <- %s' % (component, version, directory))


class VirtualenvDirectory(BuildDirectory):

    '''
    It does the samething with the BuildDirectory
    with additional virtualenv init.
    '''

    def __init__(self, directory, configuration):
        super(VirtualenvDirectory, self).__init__(directory, configuration)
        self.clean_commands = False

    def configure(self, options, args):
        self.virtualenv_command(self.directory)
        super(VirtualenvDirectory, self).configure(options, args)

    def which(self, program):
        def is_exe(fpath):
            return os.path.exists(fpath) and os.access(fpath, os.X_OK)

        def ext_candidates(fpath):
            yield fpath
            for ext in os.environ.get("PATHEXT", "").split(os.pathsep):
                yield fpath + ext
        fpath, fname = os.path.split(program)
        if fpath:
            if is_exe(program):
                return program
        else:
            for path in os.environ["PATH"].split(os.pathsep):
                exe_file = os.path.join(path, program)
                for candidate in ext_candidates(exe_file):
                    if is_exe(candidate):
                        return candidate
        return None

    def virtualenv_command(self, env_path):
        if not self.which("virtualenv"):
            raise ValueError("Cannot find virtual. Please install virtualenv.")
        active_path = os.path.join(env_path, "bin", "activate")
        if not os.path.isfile(active_path):
            cmd = ["virtualenv",  "--system-site-packages"]
            cmd.append(env_path)
            system(*cmd)
        else:
            print("No need to virtualenv init '%s' since it is already initialized." \
                % env_path)
        pass


class PackageDirectory(ComponentsConfigParser):

    _validOptions = set(('build_directory', 'packaging_options',
                         'packaging_thirdparty', 'build_condition',
                         'installer_filename', 'data_repos_dir',
                         'test_install_dir', 'remote_test_host_cmd',
                         'init_components_from_build_dir', 'pack_version',
                         'default_steps'))

    def __init__(self, directory, configuration):
        super(PackageDirectory, self).__init__(directory, configuration)
        self.build_directory = ''
        self.packaging_options = ''
        #self.packaging_thirdparty = ''
        self.build_condition = None
        self.installer_filename = None
        self.data_repos_dir = ''
        self.test_install_dir = ''
        self.remote_test_host_cmd = None
        self.init_components_from_build_dir = 'ON'
        self.pack_version = None
        self.pathvars = None
        self.default_steps = []

    def addConfigurationLine(self, line):
        # Supported lines in bv_maker.cfg for [ pack ... ]:
        i = line.find('=')
        if i > 0:
            option = line[:i].strip()
            value = line[i + 1:].strip()
            if option not in self._validOptions:
                raise SyntaxError()
            if hasattr(self, option) \
                    and type(getattr(self, option)) in (list, tuple):
                value = value.split()
            if option == 'build_directory':
                value = os.path.normpath(
                    os.path.abspath(environmentVariablesSubstitution(
                        value)))
            setattr(self, option, value)
        else:
            l = line.split(None, 2)
        self.configurationLines.append(line)

    def conditional_build(self):
        '''Tells if the current package has actually to be built.
        If a condition option is False, it will not.
        '''
        if not self.build_condition:
            return True
        cond = True
        try:
            cond = eval(self.build_condition)
        except Exception as e:
            print('Package directory', self.directory, ': error in parsing build_condition option:', file=sys.stderr)
            print(self.build_condition, file=sys.stderr)
            print('(Condition is evaluated as python expression). Error:', sys.stderr)
            print(e, file=sys.stderr)
            raise
        return cond

    def test_config(self, options, args):
        if not self.conditional_build():
            return
        build_dir = configuration.buildDirectories.get(self.build_directory)
        if build_dir is None:
            raise RuntimeError(
                'Package directory: referenced build directory: "%s" does '
                'not exist' % self.build_directory)
        self.build_dir = build_dir
        if self.init_components_from_build_dir.upper() == 'ON':
            build_dir._process_configuration_lines()
            self.projects = build_dir.projects
            self.components = build_dir.components
        self._process_configuration_lines()

    #def installer_cmdline_i2bm(self):
        #pack_options = self.packaging_options.split()
        #installer_filename = self.installer_filename
        #if not installer_filename:
            #installer_filename = os.path.join(
                #os.path.dirname(self.directory),
                #'brainvisa-installer/brainvisa_installer-'
                #'%(version)s-%(os)s-%(online)s%(public)s')
        #cmd = [sys.executable,
               #distutils.spawn.find_executable('bv_build_installer_i2bm'),
               #'-m', self.directory, '-o', installer_filename] \
            #+ pack_options
        #return cmd

    def installer_variables(self):
        if self.pathvars is not None:
            return self.pathvars
        systems = {'darwin' : 'osx'}
        i2bm_str = 'public'
        osname = platform.system().lower()
        osname = systems.get(osname, osname)
        public = ''
        online = 'online'
        if osname == 'linux':
            if platform.architecture()[0] == '64bit':
                osname += '64'
            else:
                osname += '32'
            # determine libc version - using ctypes and calling C
            # gnu_get_libc_version() function
            # Note: plaform.libc_ver() is completely bogus.
            import ctypes
            libc = ctypes.cdll.LoadLibrary("libc.so.6")
            gnu_get_libc_version = libc.gnu_get_libc_version
            gnu_get_libc_version.restype = ctypes.c_char_p
            osname += '-glibc-' \
                + '.'.join(gnu_get_libc_version().split('.')[:2])
        elif osname == 'windows':
            osname = 'win32'
            # how is is for win64 ?

        if '--i2bm' in self.packaging_options.split():
            i2bm_str = 'i2bm'
            public = '-i2bm'

        if self.pack_version:
            fullVersion = self.pack_version
        else:
            fullVersion = '1.0.0'
            bvconf = os.path.join(self.build_directory, 'python', 'brainvisa',
                                  'config.py')
            if os.path.exists(bvconf):
                ver = {}
                try:
                    with open(bvconf) as f:
                        code = compile(f.read(), bvconf, 'exec')
                        exec(code, ver, ver)
                    fullVersion = ver.get('fullVersion', fullVersion)
                except ImportError:
                    pass

        self.pathvars = {'i2bm': i2bm_str, 'os': osname,
                         'version': fullVersion, 'public': public,
                         'online': online}
        return self.pathvars

    def replace_vars(self, path_string):
        vars = self.installer_variables()
        return os.path.abspath(
            environmentVariablesSubstitution(path_string)) % vars

    def installer_cmdline(self):
        components = self.components.keys()
        projects = list(self.projects)
        pack_options = self.packaging_options.split()
        installer_filename = self.installer_filename
        #if not installer_filename:
            #installer_filename = os.path.join(
                #os.path.dirname(self.directory),
                #'brainvisa-installer/brainvisa_installer-'
                #'%(version)s-%(os)s-%(online)s%(public)s')
        if installer_filename:
            installer_filename = self.replace_vars(installer_filename)
        directory = self.directory
        directory = self.replace_vars(directory)
        cmd = [sys.executable,
               distutils.spawn.find_executable('bv_build_installer.py'),
               '-r', directory]
        if installer_filename:
            cmd += ['-i', installer_filename]
        cmd += pack_options + ['-p'] + projects + ['-n'] + components
        return cmd

    def make_install_script(self, install_dir, repos_dir, data_repos_dir,
                            temp_dir=None):

        fd, script_fname = tempfile.mkstemp(prefix='install_script',
                                            dir=temp_dir)
        if data_repos_dir:
            data_repos_dir_url = ', "file://%s"' % data_repos_dir
        else:
            data_repos_dir_url = ""
        os.close(fd)
        f = open(script_fname, 'w')
        f.write('''var install_dir = "%s";
var repositories = ["file://%s"%s];

function Controller()
{
}

Controller.prototype.IntroductionPageCallback = function()
{
    var widget = gui.currentPageWidget(); // get the current wizard page
//     gui.clickButton(buttons.CustomButton1); // parameters
    installer.setTemporaryRepositories(repositories, true);
    gui.clickButton(buttons.NextButton)
}

Controller.prototype.TargetDirectoryPageCallback = function()
{
    var widget = gui.currentPageWidget();
    widget.TargetDirectoryLineEdit.setText(install_dir);
    gui.clickButton(buttons.NextButton);
}

Controller.prototype.ComponentSelectionPageCallback = function()
{
    var widget = gui.currentPageWidget();
    widget.selectAll();
    gui.clickButton(buttons.NextButton);
}

Controller.prototype.LicenseAgreementPageCallback = function()
{
    var widget = gui.currentPageWidget();
    widget.AcceptLicenseRadioButton.setChecked(true);
    gui.clickButton(buttons.NextButton);
}

Controller.prototype.ReadyForInstallationPageCallback = function()
{
    gui.clickButton(buttons.CommitButton);
}

Controller.prototype.PerformInstallationPageCallback = function()
{
    gui.clickButton(buttons.CommitButton);
}

Controller.prototype.FinishedPageCallback = function()
{
    gui.clickButton(buttons.FinishButton);
}
''' % (install_dir, repos_dir, data_repos_dir_url))
        f.close()
        return script_fname

    def package(self, options, args):
        self.test_config(options, args)
        directory = self.replace_vars(self.directory)
        print('Building package:', directory)
        print('    from build dir:', self.build_dir.directory)
        cmd = self.installer_cmdline()
        print('running:', "'" + "' '".join(cmd) + "'")
        subprocess.check_call(cmd, cwd=self.build_dir.directory)

    def install_package(self, options, args):
        self.test_config(options, args)
        directory = self.replace_vars(self.directory)
        if not self.test_install_dir:
            return
        print('Installing package:', directory)
        print('    from build dir:', self.build_dir.directory)
        test_install_dir = self.replace_vars(self.test_install_dir)
        print('    to:', test_install_dir)
        tmp_dir = None
        if self.remote_test_host_cmd:
            print('    remote:', self.remote_test_host_cmd)
            tmp_dir = os.path.join(os.path.dirname(test_install_dir), 'tmp')
            if not os.path.exists(tmp_dir):
                os.mkdir(tmp_dir)
        repos_dir = directory
        if self.data_repos_dir:
            data_repos_dir = self.replace_vars(self.data_repos_dir)
        else:
            data_repos_dir = None
        install_dir = test_install_dir
        installer_filename = self.replace_vars(self.installer_filename)
        if os.path.isdir(install_dir):
            print('removing previous test installation...')
            shutil.rmtree(install_dir)
        install_script = self.make_install_script(
            install_dir, repos_dir, data_repos_dir, temp_dir=tmp_dir)
        cmd = []
        if self.remote_test_host_cmd:
            cmd = shlex.split(self.remote_test_host_cmd)
        cmd += [installer_filename, '--script', install_script]
        try:
            print('installing...')
            cmd = '"' + '" "'.join(cmd) + '"'
            print(cmd)
            subprocess.check_call(cmd, shell=True)
            print('done.')
        finally:
            os.unlink(install_script)


    def test_package(self, options, args):
        self.test_config(options, args)
        if not self.test_install_dir:
            raise RuntimeError(
                'install_pack command needs test_install_dir option')
        print('Testing package:', self.directory)
        print('    from build dir:', self.build_dir.directory)
        install_dir = self.replace_vars(self.test_install_dir)
        # get parallel jobs option if specified
        make_opts = self.build_dir.make_options.split()
        # set environment to point to install dir
        new_env = dict(os.environ)
        new_env['BRAINVISA_PACKAGE_INSTALL_PREFIX'] = install_dir
        if self.remote_test_host_cmd:
            new_env['BRAINVISA_TEST_REMOTE_COMMAND'] \
                = self.remote_test_host_cmd
        system(cwd=self.build_dir.directory, env=new_env,
               *(['ctest', '--output-on-failure']))


# ---

commands = {
    'info': InfoCommand,
    'sources': SourcesCommand,
    'configure': ConfigureCommand,
    'build': BuildCommand,
    'doc': DocCommand,
    'test': TestCommand,
    'pack' : PackCommand,
    'install_pack': InstallPackCommand,
    'test_pack': TestPackCommand,
}

default_commands = ['info', 'sources', 'configure', 'build', 'doc', 'test']
options_by_command = {None: []}
command = None
for i in sys.argv[1:]:
    if i in commands:
        command = i
        if command in options_by_command:
            raise ValueError('Command %s used twice' % command)
        options_by_command[command] = []
    else:
        options_by_command[command].append(i)

# Initialize global configuration
configuration = GlobalConfiguration(options_by_command[None])

# Parse commands options and prepare them for processing in the correct order
todo = []
if len(options_by_command) == 1:
    # No command selected => do all default commands
    for i in default_commands:
        options_by_command[i] = ['--only-if-default']
# Ordered command list
for command in ['info', 'sources', 'configure', 'build', 'doc', 'test',
                'pack', 'install_pack', 'test_pack']:
    if command in options_by_command:
        todo.append(
            commands[command](options_by_command[command], configuration))

# Execute selected commands
for f in todo:
    f()
