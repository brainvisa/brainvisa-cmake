#!/usr/bin/env python
# -*- coding: utf-8 -*-

#  This software and supporting documentation are distributed by
#      Institut Federatif de Recherche 49
#      CEA/NeuroSpin, Batiment 145,
#      91191 Gif-sur-Yvette cedex
#      France
#
# This software is governed by the CeCILL-B license under
# French law and abiding by the rules of distribution of free software.
# You can  use, modify and/or redistribute the software under the 
# terms of the CeCILL-B license as circulated by CEA, CNRS
# and INRIA at the following URL "http://www.cecill.info". 
#
# As a counterpart to the access to the source code and  rights to copy,
# modify and redistribute granted by the license, users are provided only
# with a limited warranty  and the software's author,  the holder of the
# economic rights,  and the successive licensors  have only  limited
# liability.
#
# In this respect, the user's attention is drawn to the risks associated
# with loading,  using,  modifying and/or developing or reproducing the
# software by the user in light of its specific status of free software,
# that may mean  that it is complicated to manipulate,  and  that  also
# therefore means  that it is reserved for developers  and  experienced
# professionals having in-depth computer knowledge. Users are therefore
# encouraged to load and test the software's suitability as regards their
# requirements in conditions enabling the security of their systems and/or 
# data to be ensured and,  more generally, to use and operate it in the 
# same conditions as regards security.
#
# The fact that you are presently reading this means that you have had
# knowledge of the CeCILL-B license and that you accept its terms.

import sys, os, re, pprint, subprocess, glob, shutil
from optparse import OptionParser
from fnmatch import fnmatchcase

if os.path.exists( sys.argv[0] ):
  this_script = sys.argv[0]
else:
  this_script = None
  for p in os.environ.get( 'PATH', '' ).split( os.pathsep ) + [ os.curdir ]:
    s = os.path.join( p, sys.argv[0] )
    if os.path.exists( s ):
      this_script = s
      break
if this_script:
  this_script = os.path.normpath( os.path.abspath( this_script ) )
  python_modules = os.path.join( os.path.dirname( os.path.dirname( this_script ) ), 'python' )
  if os.path.isdir( python_modules ):
    sys.path.insert( 0, python_modules )

from brainvisa.maker.brainvisa_projects import *
from brainvisa.maker.bioproj_parser import BRAINVISA_SVN_URL, SVN_URL, getBrainVISAComponents, getMatchingURLs

def system( *args, **kwargs ):
  print ' '.join( args )
  result = subprocess.call( args, **kwargs )
  if result != 0:
    raise OSError( 'Command failed: ' + ' '.join( ( repr(i) for i in args ) ) )

def cmake_path( path ):
  if sys.platform == 'win32':
    return path.replace( '\\', '/' )
  else :
    return path
    
def copy_brainvisa_cmake( installDir ):
  global this_script
  sourceDir = os.path.dirname( os.path.dirname( this_script ) )
  samefile = getattr( os.path, 'samefile', None )
  if samefile:
    samefile = samefile( sourceDir, installDir )
  else:
    samefile = sourceDir == installDir
  if samefile:
    return
  import brainvisa.maker
  for f in open( os.path.join( os.path.dirname( brainvisa.maker.__file__ ), 'installed_files.txt' ) ):
    p, f = os.path.split( f.strip() )
    d = os.path.join( installDir, p )
    if not os.path.exists( d ):
      os.makedirs( d )
    shutil.copy( os.path.join( sourceDir, p, f ), d )
    


def environmentVariablesSubstitution( path ):
  result = path
  r = re.compile( r'\$([A-Za-z0-9_]*)' )
  offset = 0
  for m in r.finditer( path ):
    variableContent = os.environ.get( m.group(1) )
    if variableContent is not None:
      start, end = m.span()
      start += offset
      end += offset
      offset += len( variableContent ) - end + start
      result = result[ :start ] + variableContent + result[ end :  ]
  return result







class GlobalConfiguration( object ):
  def __init__( self, argv ):
    usage = '''%prog [options] [ command [command options] ]...
    
    This program is for the management of source retrieval, configuration and compilation of BrainVISA projects.
    
    In order to work, the commands svn and svnadmin must be installed on your system. On some Linux systems they are in two separate packages (e.g. subversion and subversion-tools).
    
    Commands:
      sources: Create or updated selected sources directories from Subversion repository.
      configure: Create and configure selected build directories with CMake.
      build: compile all selected build directories.
      doc: Generate documentation (docbook, epydoc, doxygen)
    
    To get help for a specific command, use -h option of the command. Example: "%prog build -h".
    '''
    defaultConfigurationFile = os.path.join( os.environ[ 'HOME' ], '.brainvisa', 'bv_maker.cfg' )
    parser = OptionParser(usage=usage)
    parser.add_option( '-d', '--directory', dest='directories',
                      help='Restrict actions to a selected directory. May be used several times to process several directories.',
                      metavar='DIR', action='append', default=[] )
    parser.add_option( '-c', '--config', dest='configuration_file',
                      help='specify configuration file. Default ="' + defaultConfigurationFile + '"',
                      metavar='USERNAME', default=None )
    parser.add_option( '-s', '--sources', dest='sources_directory',
                      help='directory containing sources',
                      metavar='DIR', default=None )
    parser.add_option( '-b', '--build', dest='build_directory',
                      help='build directory',
                      metavar='DIR', default=None )
    parser.add_option( '--username', dest='username',
                      help='specify user login to use with the svn server',
                      metavar='USERNAME', default='' )
    parser.add_option( '-v', '--verbose', dest='verbose', action='store_true',
                      help='show as much information as possible' )
    
    (options, args) = parser.parse_args( argv )
    if args:
      raise ValueError( 'Invalid option: %s' % args[0] )
   
    packages = []
    lineCount = 0
    currentDirectoryObject = None
    self.sourcesDirectories = {}
    self.buildDirectories = {}

    if options.build_directory:
      if not options.sources_directory:
        options.sources_directory = os.path.dirname( os.path.dirname( this_script ) )
      bd = BuildDirectory( environmentVariablesSubstitution( options.build_directory ), self )
      self.buildDirectories[ bd.directory ] = bd
      bd.addConfigurationLine( 'all * ' + options.sources_directory )
    elif not options.configuration_file:
      options.configuration_file = defaultConfigurationFile
    
    for i in ( 'configuration_file', 'username', 'verbose' ):
      setattr( self, i, getattr( options, i ) )

    if options.configuration_file:
      # Read configuration file
      for line in open( options.configuration_file ):
        lineCount += 1
        line = line.strip()
        if not line or line[0] == '#' or line.startswith( '//' ): continue
        try:
          if line[0] == '[':
            if line[-1] != ']': raise SyntaxError()
            l = line[1:-1].split( None, 1 )
            if len( l ) != 2:
              raise SyntaxError()
            if l[ 0 ] == 'source':
              pass
              currentDirectoryObject = SourceDirectory( environmentVariablesSubstitution( l[ 1 ].strip() ), self )
              self.sourcesDirectories[ currentDirectoryObject.directory ] = currentDirectoryObject
            elif l[ 0 ] == 'build':
              pass
              currentDirectoryObject = BuildDirectory( environmentVariablesSubstitution( l[ 1 ].strip() ), self )
              self.buildDirectories[ currentDirectoryObject.directory ] = currentDirectoryObject
            else:
              raise SyntaxError()
          else:
            if currentDirectoryObject is None: raise SyntaxError()
            if self.verbose:
              print '  processing line:', repr( line )
            currentDirectoryObject.addConfigurationLine( line )
        except SyntaxError:
          raise SyntaxError( 'Syntax error in ' + repr( options.configuration_file ) + ' on line ' + str( lineCount ) )


class InfoCommand( object ):
  def __init__( self, argv, configuration ):
    usage = '''%prog [global options] info [options]
    
    Display information about configuration, sources directories and build directories.'''
    parser = OptionParser(usage=usage)
    (options, args) = parser.parse_args( argv )
    if args:
      raise ValueError( 'Invalid option: %s' % args[0] )
  
  
  def __call__( self ):
    print 'Configuration file:', configuration.configuration_file
    for d, o in configuration.sourcesDirectories.iteritems():
      o.info()
    for d, o in configuration.buildDirectories.iteritems():
      o.info()


class SourcesCommand( object ):
  def __init__( self, argv, configuration ):
    usage = '''%prog [global options] sources [options]
    
    Create or updated selected sources directories from Subversion repository.'''
    parser = OptionParser(usage=usage)
    (options, args) = parser.parse_args( argv )
    if args:
      raise ValueError( 'Invalid option: %s' % args[0] )
  
  
  def __call__( self ):
    for d, o in configuration.sourcesDirectories.iteritems():
      o.process()


class ConfigureCommand( object ):
  def __init__( self, argv, configuration ):
    usage = '''%prog [global options] configure [options]
    
    Create or updated selected build directories.'''
    parser = OptionParser(usage=usage)
    (options, args) = parser.parse_args( argv )
    if args:
      raise ValueError( 'Invalid option: %s' % args[0] )
  
  
  def __call__( self ):
    for d, o in configuration.buildDirectories.iteritems():
      o.configure()


class CompileCommand( object ):
  def __init__( self, argv, configuration ):
    command = [ ( 'build' if i == 'compile' else i ) for i in sys.argv ]
    raise ValueError( 'Command "compile" have been renamed to "build". Please use the following command-line: %s' % ' '.join( ( repr(i) for i in command ) ) )
  


class BuildCommand( object ):
  def __init__( self, argv, configuration ):
    usage = '''%prog [global options] configure [options]
    
    Compile selected build directories.'''
    parser = OptionParser(usage=usage)
    (options, args) = parser.parse_args( argv )
    if args:
      raise ValueError( 'Invalid option: %s' % args[0] )
  
  
  def __call__( self ):
    for d, o in configuration.buildDirectories.iteritems():
      o.build()

class DocCommand( object ):
  def __init__( self, argv, configuration ):
    usage = '''%prog [global options] doc [options]
    
    Generate documentation (docbook, epydoc, doxygen).'''
    parser = OptionParser(usage=usage)
    (options, args) = parser.parse_args( argv )
    if args:
      raise ValueError( 'Invalid option: %s' % args[0] )
  
  
  def __call__( self ):
    for d, o in configuration.buildDirectories.iteritems():
      o.doc()


class SourceDirectory( object ):
  def __init__( self, directory, configuration ):
    self.configuration = configuration
    self.directory = os.path.normpath( os.path.abspath( directory ) )
    self.configurationLines = []
    self.componentVersionPerURL = {}
    self.otherComponentsDirectory = set()
  
  
  def addConfigurationLine( self, line ):
    l = line.split()
    if len(l) < 2 or len( l ) > 3:
      raise SyntaxError()
    sign = l[0]
    componentsPattern = l[1]
    if len( l ) == 3:
      versionPattern = l[2]
    else:
      versionPattern = None
    if sign == '+':
      if '/' in componentsPattern:
        if '*' in componentsPattern:
          raise SyntaxError()
        url = SVN_URL + '/' + componentsPattern
        if self.configuration.verbose:
          print '    adding url:', url
        self.otherComponentsDirectory.add( ( componentsPattern, versionPattern or componentsPattern )  )
      else:
        if versionPattern is None:
          raise SyntaxError()
        for component in getBrainVISAComponents( componentsPattern ):
          if self.configuration.verbose:
            print '    considering component:', component
          for url in getMatchingURLs( component, versionPattern ):
            if self.configuration.verbose:
              print '      adding url:', url
            self.componentVersionPerURL[ url[2] ] = ( url[0], url[1] )
    elif sign == '-':
      if '/' in componentsPattern:
        raise SyntaxError()
      else:
        if versionPattern is None:
          versionPattern = '*'
        for component in getBrainVISAComponents( componentsPattern ):
          if self.configuration.verbose:
            print '    considering component:', component
          for url in getMatchingURLs( component, versionPattern ):
            if self.configuration.verbose:
              print '      removing url:', url
            self.componentVersionPerURL.pop( url[2], None )
    else:
      raise SyntaxError()
    self.configurationLines.append( line )
  
  
  def process( self ):
    if not os.path.exists( self.directory ):
      os.makedirs( self.directory )
    clientFile = open( os.path.join( self.directory, 'bv_maker.cfg' ), 'w' )
    print >> clientFile, '\n'.join( self.configurationLines )
    
    repositoryDirectory = os.path.join( self.directory, '.repository' )
    checkout = False
    if not os.path.exists( repositoryDirectory ):
      os.makedirs( repositoryDirectory )
      # Because of a bug in svnadmin on MacOS, I cannot use an absolute name for the directory to create.
      # When I try "svnadmin create /neurospin/brainvisa/cmake_mac/", I have the following error:
      # svnadmin: '/neurospin/brainvisa/cmake_mac' is a subdirectory of an existing repository rooted at '/neurospin'
      # But it works if I do "cd /neurospin/brainvisa && vnadmin create cmake_mac"
      cwd, dir = os.path.split( repositoryDirectory )
      system( 'svnadmin', 'create', dir, cwd=cwd )
      
      if len( os.path.splitdrive(repositoryDirectory)[0] ) > 0:
        # This is for windows absolute pathes
        repositoryDirectory = '/' + repositoryDirectory.replace(os.path.sep, "/")
        
      self.svncommand( 'checkout',  'file://' + repositoryDirectory, self.directory )
      checkout = True
    self.updateExternals()
    self.svncommand( 'update', self.directory )
  
  

  def svncommand( self, *svnargs ):
    cmd = [ 'svn' ]
    if self.configuration.username:
      cmd += [ ' --username', self.configuration.username ]
    cmd.extend( svnargs )
    system( *cmd )



  def updateExternals( self ):
    externalsFileName = os.path.join( self.directory, 'bv_maker.externals' )
    externalsFile = open( externalsFileName, 'w' )
    self.clients = {}
    
    for url, component_version in self.componentVersionPerURL.iteritems():
      component, version = component_version
      self.clients.setdefault( version, {} ).setdefault( brainvisaProjectPerComponent.get( component ), [] ).append( url )
      
    currentProject = None
    for version, content in self.clients.iteritems():
      if version:
        print >> externalsFile, '#', version, 'version'
      else:
        print >> externalsFile, '# Directories'
      for project, urls in content.iteritems():
        for url in urls:
          print >> externalsFile, url[ len( BRAINVISA_SVN_URL ) + 1: ], url
        print >> externalsFile
    for source, dest in self.otherComponentsDirectory:
      print >> externalsFile, dest, SVN_URL + '/' + source
    externalsFile.close()

    self.svncommand( 'propset', 'svn:externals', '--file', externalsFileName, self.directory )
    self.svncommand( 'commit', '-m', '', self.directory )

  def info( self ):
    print 'Source directory: "' + self.directory + '"'
    
    self.clients = {}
    for url, component_version in self.componentVersionPerURL.iteritems():
      component, version = component_version
      self.clients.setdefault( version, {} ).setdefault( brainvisaProjectPerComponent.get( component ), [] ).append( url )
      
    currentProject = None
    for version, content in self.clients.iteritems():
      for project, urls in content.iteritems():
        for url in urls:
          print ' ', url[ len( BRAINVISA_SVN_URL ) + 1: ], '<-', url
    for source, dest in self.otherComponentsDirectory:
      print ' ', dest, '<--', SVN_URL + '/' + source





class BuildDirectory( object ):
  _validOptions = set( ( 'build_type', 'make_options', 'packaging_thirdparty' ) )
  
  def __init__( self, directory, configuration ):
    self.configuration = configuration
    self.directory = os.path.normpath( os.path.abspath( directory ) )
    self.configurationLines = []
    self.configurationDirectories = []
    self.projects = set()
    self.components = {}
    self.build_type = ''
    self.make_options = ''
    self.packaging_thirdparty = ''
  
  
  def addConfigurationLine( self, line ):
    i = line.find( '=' )
    if i > 0:
      option = line[ :i ].strip()
      value = line[ i+1: ].strip()
      if option not in self._validOptions:
        raise SyntaxError()
      setattr( self, option, value )
    elif line[ 0 ] == '+':
        if '*' in line:
          raise SyntaxError()
        self.configurationDirectories.append( os.path.normpath( os.path.abspath( environmentVariablesSubstitution( line[ 1: ].strip() ) ) ) )
    elif line[ 0 ] == '-':
      componentsPattern = line[ 1: ].strip()
      for component in getBrainVISAComponents( componentsPattern ):
        self.components.pop( component, None )
    else:
      l = line.split( None, 2 )
      if len(l) != 3:
        raise SyntaxError()
      componentsPattern, versionPattern, sourceDirectory = l
      sourceDirectory = os.path.normpath( os.path.abspath( environmentVariablesSubstitution( sourceDirectory ) ) )
      for component in getBrainVISAComponents( componentsPattern ):
        if self.configuration.verbose:
          print '  considering component:', component
        for component, version, url in getMatchingURLs( component, versionPattern ):
          componentSourcesDirectory = os.path.join( sourceDirectory, url[ len( BRAINVISA_SVN_URL ) + 1: ] )
          if os.path.exists( componentSourcesDirectory ):
            self.components[ component ] = ( componentSourcesDirectory, None )
            if self.configuration.verbose:
              print "    " + component + " source directory '" + componentSourcesDirectory + "'"
            self.projects.add( brainvisaProjectPerComponent[ component ] )
    self.configurationLines.append( line )




  
  def configure( self ):
    for directory in self.configurationDirectories:
      os.stat( directory ) # Raise appropriate error if directory does not exist
      project_info = os.path.join( directory, 'project_info.cmake' )
      if os.path.exists( project_info ):
        project = None
        component = None
        version = [ '', '' ]
        p = re.compile( r'\s*set\(\s*([^ \t]*)\s*(.*[^ \t])\s*\)' )
        for line in open( project_info ):
          match = p.match( line )
          if match:
            variable, value = match.groups()
            if variable == 'BRAINVISA_PACKAGE_NAME':
              component = value
            elif variable == 'BRAINVISA_PACKAGE_MAIN_PROJECT':
              project = value
            elif variable == 'BRAINVISA_PACKAGE_VERSION_MAJOR':
              version[ 0 ] = value
            elif variable == 'BRAINVISA_PACKAGE_VERSION_MINOR':
              version[ 1 ] = value
        if project:
          self.projects.add( project )
        if component:
          self.components[ component ] = ( directory, '.'.join( version ) )
      else:
        print >> sys.stderr, "WARNING: ignoring directory '%s' because it does not contain project_info.cmake" % directory
    
    if not os.path.exists( self.directory ):
      os.makedirs( self.directory )
    copy_brainvisa_cmake( self.directory )
    cmakeFile = os.path.join( self.directory, 'bv_maker.cmake' )
    out = open( cmakeFile, 'w' )
    
    for component, directory_version in self.components.items():
      directory, version = directory_version
      project_info = os.path.join( directory, 'project_info.cmake' )
      if not os.path.exists( project_info ):
        del self.components[ component ]
      elif version is None:
        version = [ '', '' ]
        p = re.compile( r'\s*set\(\s*([^ \t]*)\s*(.*[^ \t])\s*\)' )
        for line in open( project_info ):
          match = p.match( line )
          if match:
            variable, value = match.groups()
            if variable == 'BRAINVISA_PACKAGE_VERSION_MAJOR':
              version[ 0 ] = value
            elif variable == 'BRAINVISA_PACKAGE_VERSION_MINOR':
              version[ 1 ] = value
        self.components[ component ] = ( directory, '.'.join( version ) )
    
    # Order of projects and components is important for dependencies
    sortedProjects = [ p for p in brainvisaProjects if p in self.projects ]
    sortedComponents = []
    components = set( self.components )
    for project in sortedProjects:
      for component in brainvisaComponentsPerProject[ project ]:
        if component in components:
          sortedComponents.append( component )
          components.remove( component )
    sortedComponents.extend( components )
    print >> out, 'set( BRAINVISA_PROJECTS', ' '.join( sortedProjects ),'CACHE STRING "BrainVISA Projects list" FORCE )'
    print >> out, 'set( _BRAINVISA_PROJECTS', ' '.join( sortedProjects ),'CACHE STRING "BrainVISA Projects list" FORCE )'
    print >> out, 'set( BRAINVISA_COMPONENTS', ' '.join( sortedComponents ),'CACHE STRING "BrainVISA components list" FORCE )'
    print >> out, 'set( _BRAINVISA_COMPONENTS', ' '.join( sortedComponents ),'CACHE STRING "BrainVISA components list" FORCE )'
    print >> out
    for component, directory_version in self.components.iteritems():
      directory, version = directory_version
      print >> out, 'set( BRAINVISA_SOURCES_' + component + ' "' + cmake_path( directory ) + '" CACHE STRING "Sources directory for component ' + component + '" FORCE )'
      print >> out, 'set( ' + component + '_DIR "' + cmake_path( self.directory ) + '/share/' + component + '-' + version + '/cmake " CACHE STRING "Directory used for find_package( ' + component + ' )" FORCE )'

    cmakeLists = os.path.join( self.directory, 'CMakeLists.txt' )
    out.close()
    out = open( cmakeLists, 'w' )
    print >> out, '''
cmake_minimum_required( VERSION 2.6 )
set( CMAKE_PREFIX_PATH "${CMAKE_BINARY_DIR}" ${CMAKE_PREFIX_PATH} )
find_package( brainvisa-cmake NO_POLICY_SCOPE )
include( "${brainvisa-cmake_DIR}/brainvisa-compilation.cmake" )
'''
    out.close()
    if sys.platform == 'win32':
      command = [ 'cmake', '-G', 'MSYS Makefiles' ]
    else:
      command = [ 'cmake' ]

    command += [ '-DCMAKE_BUILD_TYPE:STRING=' + self.build_type, cmake_path( self.directory ) ]
    if self.packaging_thirdparty == 'ON':
      command += ['-DBRAINVISA_PACKAGING_THIRDPARTY=ON']

    system( cwd = self.directory, *command )
  
  
  def build( self ):
    system( cwd=self.directory, *( ['make'] + self.make_options.split() ) )

  def doc( self ):
    system( cwd=self.directory, *( ['make'] + self.make_options.split() + ['-j1', 'doc'] ) )
  
  
  def info( self ):
    print 'Build directory: "' + self.directory + '"'
    for directory in self.configurationDirectories:
      os.stat( directory ) # Raise appropriate error if directory does not exist
      project_info = os.path.join( directory, 'project_info.cmake' )
      if os.path.exists( project_info ):
        project = None
        component = None
        version = [ '', '' ]
        p = re.compile( r'\s*set\(\s*([^ \t]*)\s*(.*[^ \t])\s*\)' )
        for line in open( project_info ):
          match = p.match( line )
          if match:
            variable, value = match.groups()
            if variable == 'BRAINVISA_PACKAGE_NAME':
              component = value
            elif variable == 'BRAINVISA_PACKAGE_MAIN_PROJECT':
              project = value
            elif variable == 'BRAINVISA_PACKAGE_VERSION_MAJOR':
              version[ 0 ] = value
            elif variable == 'BRAINVISA_PACKAGE_VERSION_MINOR':
              version[ 1 ] = value
        if project:
          self.projects.add( project )
        if component:
          self.components[ component ] = ( directory, '.'.join( version ) )
    
    for component, directory_version in self.components.items():
      directory, version = directory_version
      project_info = os.path.join( directory, 'project_info.cmake' )
      if not os.path.exists( project_info ):
        del self.components[ component ]
      elif version is None:
        version = [ '', '' ]
        p = re.compile( r'\s*set\(\s*([^ \t]*)\s*(.*[^ \t])\s*\)' )
        for line in open( project_info ):
          match = p.match( line )
          if match:
            variable, value = match.groups()
            if variable == 'BRAINVISA_PACKAGE_VERSION_MAJOR':
              version[ 0 ] = value
            elif variable == 'BRAINVISA_PACKAGE_VERSION_MINOR':
              version[ 1 ] = value
        self.components[ component ] = ( directory, '.'.join( version ) )

    # Order of projects and components is important for dependencies
    sortedProjects = [ p for p in brainvisaProjects if p in self.projects ]
    sortedComponents = []
    components = set( self.components )
    for project in sortedProjects:
      for component in brainvisaComponentsPerProject[ project ]:
        if component in components:
          sortedComponents.append( component )
          components.remove( component )
    sortedComponents.extend( components )
    
    for component in sortedComponents:
      directory, version = self.components[ component ]
      print ' ', component, '(' + version + ') <=', directory


commands = {
  'info': InfoCommand,
  'sources': SourcesCommand,
  'configure': ConfigureCommand,
  'build': BuildCommand,
  'doc': DocCommand,
}
default_commands = [ 'sources', 'configure', 'build' ]
options_by_command = { None: [] }
command = None
for i in sys.argv[1:]:
  if i in commands:
    command = i
    if command in options_by_command:
      raise ValueError( 'Command %s used twice' % command )
    options_by_command[ command ] = []
  else:
    options_by_command[ command ].append( i )

# Initialize global configuration
configuration = GlobalConfiguration( options_by_command[ None ] )


# Parse commands options and prepare them for processing in the correct order
todo = []
if len( options_by_command ) == 1:
  # No command selected => do all default commands
  for i in default_commands:
    options_by_command[ i ] = []
# Ordered command list
for command in [ 'info', 'sources', 'configure', 'build', 'doc' ]:
  if command in options_by_command:
    todo.append( commands[ command ]( options_by_command[ command ], configuration ) )

# Execute selected commands
for f in todo:
  f()
