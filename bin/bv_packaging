#!/usr/bin/env python
# -*- coding: utf-8 -*-

#  This software and supporting documentation are distributed by
#      Institut Federatif de Recherche 49
#      CEA/NeuroSpin, Batiment 145,
#      91191 Gif-sur-Yvette cedex
#      France
#
# This software is governed by the CeCILL-B license under
# French law and abiding by the rules of distribution of free software.
# You can  use, modify and/or redistribute the software under the 
# terms of the CeCILL-B license as circulated by CEA, CNRS
# and INRIA at the following URL "http://www.cecill.info". 
#
# As a counterpart to the access to the source code and  rights to copy,
# modify and redistribute granted by the license, users are provided only
# with a limited warranty  and the software's author,  the holder of the
# economic rights,  and the successive licensors  have only  limited
# liability.
#
# In this respect, the user's attention is drawn to the risks associated
# with loading,  using,  modifying and/or developing or reproducing the
# software by the user in light of its specific status of free software,
# that may mean  that it is complicated to manipulate,  and  that  also
# therefore means  that it is reserved for developers  and  experienced
# professionals having in-depth computer knowledge. Users are therefore
# encouraged to load and test the software's suitability as regards their
# requirements in conditions enabling the security of their systems and/or 
# data to be ensured and,  more generally, to use and operate it in the 
# same conditions as regards security.
#
# The fact that you are presently reading this means that you have had
# knowledge of the CeCILL-B license and that you accept its terms.

import sys, os, re, fnmatch, subprocess, tempfile, shutil, glob
from stat import S_IRUSR, S_IXUSR, S_IRGRP, S_IXGRP, S_IROTH, S_IXOTH

if os.path.exists( sys.argv[0] ):
  this_script = sys.argv[0]
else:
  this_script = None
  for p in os.environ.get( 'PATH', '' ).split( os.pathsep ) + [ os.curdir ]:
    s = os.path.join( p, sys.argv[0] )
    if os.path.exists( s ):
      this_script = s
      break
if this_script:
  this_script = os.path.normpath( os.path.abspath( this_script ) )
  brainvisacmake_directory = os.path.dirname( os.path.dirname( this_script ) )
  python_modules = os.path.join( brainvisacmake_directory, 'python' )
  if os.path.isdir( python_modules ):
    sys.path.insert( 0, python_modules )


from brainvisa.compilation_info import packages_info, packages_dependencies, build_directory, build_system, build_processor

def system_call( options, command, cwd=None, env=None, return_output=False ):
  if options.verbose and not return_output:
    print
    print '->',' '.join( ( repr(i) for i in command ) )
    print
    stdout = None
    stderr = None
  else:
    stdout = subprocess.PIPE
    stderr = subprocess.STDOUT
  popen = subprocess.Popen( command,
                            stdout=stdout, stderr=stderr, cwd=cwd, env=env  )
  result = popen.communicate()[ 0 ]
  if popen.returncode:
    raise subprocess.CalledProcessError( popen.returncode, ' '.join( ( repr(i) for i in command ) ) )
  return result
  
def unixstyle_path( path ):
  if sys.platform == 'win32':
    if ( len( os.path.splitdrive( path )[0] ) > 0 ) :
      # This is an absolute windows path
      path = os.path.sep + path.replace( ':', '' )
      
    return path.replace( '\\', '/' )
  else :
    return path
    
def recursive_listdir( directory ):
  for i in os.listdir( directory ):
    item = os.path.join( directory, i )
    yield item
    if os.path.isdir( item ):
      for j in recursive_listdir( item ):
       yield j


def packages_selection( rules ):
  if not rules:
    rules = [ '+type=run', '-project=thirdparty' ]
  packages = set()
  for rule in rules:
    if not rule: continue
    if rule[ 0 ] in ( '+', '-' ):
      attributes={}
      for attribute_selection in rule[1:].split( ',' ):
        if not attribute_selection: continue
        try:
          attribute, pattern = attribute_selection.split( '=', 1 )
        except ValueError:
          attribute = 'name'
          pattern = attribute_selection
        attributes[ attribute ] = re.compile( fnmatch.translate( pattern ) )
      for package_info in packages_info.itervalues():
        selected = True
        for attribute, pattern in attributes.iteritems():
          value = package_info.get( attribute )
          if value is None:
            raise SyntaxWarning( 'Unknown attribute %s in rule %s' % ( repr( attribute ), repr( rule ) ) )
          if not pattern.match( value ):
            selected = False
            break
        if selected:
          if rule[ 0 ] == '+':
            packages.add( package_info[ 'name' ] )
          else:
            packages.discard( package_info[ 'name' ] )
    else:
      raise SyntaxWarning( 'A package selection rule must start with + or -: %s' % repr( rule ) )
    
    dependencies = set()
    todo = set( packages )
    while todo:
      package = todo.pop()
      for type, name, version, binary_independent in packages_dependencies.get( package, () ):
        if name not in packages and name not in dependencies:
          dependencies.add( name )
          todo.add( name )
  
  # brainvisa-release component must be install after all other components, 
  # so packages is converted into a list and brainvisa-release moved at the end of that list.
  if ("brainvisa-release" in packages):
    packages.remove("brainvisa-release")
    packages=list(packages)
    packages.append("brainvisa-release")
  else:
    packages=list(packages)
  dependencies=list(dependencies)
  return ( packages, dependencies )


def list_selected_packages( options, selected_packages, dependencies ):
  if options.output is None:
    out = sys.stdout
  else:
    out = open( options.output, 'w' )
  if options.dependencies and dependencies:
    print >> out, 'Selected packages:'
    indent = '  '
  else:
    indent = ''
  print >> out, indent + ('\n'+indent).join( selected_packages )
  if options.dependencies and dependencies:
    print >> out, '\nDependencies packages:'
    print >> out, '  ' + '\n  '.join( dependencies )


def create_graphviz_dependencies( options, selected_packages, dependencies ):
  if options.output is None:
    out = sys.stdout
  else:
    out = open( options.output, 'w' )
  nodes = {}
  print >> out, 'digraph packages_dependencies {'
  done = set()
  todo = selected_packages
  while todo:
    source_package = todo.pop( 0 )
    if source_package in done:
      continue
    done.add( source_package )
    source_package = packages_info[ source_package ]
    source_node = nodes.get( source_package[ 'name' ] )
    if source_node is None:
      source_node = str( len( nodes ) )
      nodes[ source_package[ 'name' ] ] = source_node
      if source_package[ 'project' ] == 'thirdparty':
        print >> out, '  %s [ label="%s", color=orange ]' % ( source_node, source_package[ 'name' ] )
      else:
        print >> out, '  %s [ label="%s" ]' % ( source_node, source_package[ 'name' ] )
    for dependency_type, dest_package, version_ranges, binary_independent  in packages_dependencies.get( source_package[ 'name' ], () ):
      if not options.dependencies and dest_package not in selected_packages:
        continue
      todo.append( dest_package )
      dest_package = packages_info[ dest_package ]
      dest_node = nodes.get( dest_package[ 'name' ] )
      if dest_node is None:
        dest_node = str( len( nodes ) )
        nodes[ dest_package[ 'name' ] ] = dest_node
        if dest_package[ 'project' ] == 'thirdparty':
          print >> out, '  %s [ label="%s", color=orange ]' % ( dest_node, dest_package[ 'name' ] )
        else:
          print >> out, '  %s [ label="%s" ]' % ( dest_node, dest_package[ 'name' ] )
      if dependency_type == 'DEPENDS':
        color='black'
      elif dependency_type == 'RECOMMENDS':
        color='green'
      else:
        color='blue'
      print >> out, '  %s -> %s [ color=%s ]' % ( source_node, dest_node, color )
  print >> out, '}'

def create_directory_package( options, selected_packages, dependencies, list_installed_paths=False ):
  if not options.output:
    raise UserWarning( 'Ouput directory must be given for this command' )
  install_directory = options.output
  if not os.path.exists( install_directory ):
    os.makedirs( install_directory )
  else:
    if list_installed_paths and os.listdir( install_directory ):
      raise UserWarning( 'This command cannot be done on an existing and non empty directory: %s' % repr( install_directory ) )
  installed_paths = {}
  current_dir=os.getcwd()
  os.chdir(build_directory)
  for package in ( selected_packages + dependencies  if options.dependencies else selected_packages ):
    print 'Installing', package
    command = [ 'make', 'BRAINVISA_INSTALL_PREFIX=' + unixstyle_path( install_directory ), 'install-' + packages_info[ package ]['component'] ]
    system_call( options, command )
    if list_installed_paths:
      # List files installed by package
      for i in ( j for j in recursive_listdir( install_directory ) if j not in installed_paths):
        installed_paths[ i ] = package
  os.chdir(current_dir)
  
  # create scripts that call bv_env before calling the command to setup environment variables
  if options.bv_env:
    bindir = os.path.join( install_directory, 'bin' )
    if not os.path.exists( bindir ):
      os.mkdir( bindir )
    if sys.platform == 'win32':
      exe_ext = '.exe'
    else :
      exe_ext = ''
    env_commands = ( 'bv_env' + exe_ext, 'bv_env.py', 'bv_env.sh', 'bv_unenv', 'bv_unenv.sh' )
    for command in env_commands:
      source = os.path.join( brainvisacmake_directory, 'bin', command )
      dest = os.path.join( bindir, command )
      if os.path.exists( dest ):
        os.remove( dest )
      shutil.copy(source, dest)
      os.chmod( dest, os.stat( source ).st_mode )
    realbindir = os.path.join( bindir, 'real-bin' )
    if not os.path.exists( realbindir ):
      os.mkdir( realbindir )
    for command in os.listdir( bindir ):
      if command in env_commands:
        continue
      source = os.path.join( bindir, command )
      
      if os.path.isdir( source ):
        if command[-4:] == '.app': # MacOS GUI commands
          dest = os.path.join( realbindir, command )
          # first move the entire tree
          if not os.path.exists( dest ):
            os.rename( source, dest)
          elif os.path.exists( source ):
            shutil.rmtree( source )
          # then recreate it
          os.mkdir( source )
          os.mkdir( os.path.join( source, 'Contents' ) )
          os.mkdir( os.path.join( source, 'Contents', 'MacOS' ) )
          if os.path.exists( os.path.join( dest, 'Contents', 'Info.plist' ) ):
            os.symlink( os.path.join( '../../real-bin', command, 'Contents', 
                                      'Info.plist' ), 
                        os.path.join( source, 'Contents', 'Info.plist' ) )
          if os.path.exists( os.path.join( dest, 'Contents', 'PkgInfo' ) ):
            os.symlink( os.path.join( '../../real-bin', command, 'Contents', 
                                      'PkgInfo' ), 
                        os.path.join( source, 'Contents', 'PkgInfo' ) )
          icns = os.path.join( 'Contents', 'Resources', command[:-4] + '.icns' )
          if os.path.exists( os.path.join( dest, icns ) ):
            os.mkdir( os.path.join( source, 'Contents', 'Resources' ) )
            os.symlink( os.path.join( '../../../real-bin', command, icns ), 
                        os.path.join( source, icns ) )
          bapp = command[:-4].lower()
          bappsrc = os.path.join( bindir, bapp )
          bappdst = os.path.join( realbindir, command[:-4] )
          if os.path.islink( bappsrc ):
            if os.path.exists( bappdst ):
              os.unlink( bappdst )
            os.symlink( os.readlink( bappsrc ), bappdst )
          # Generate the script
          scriptfile=os.path.join(source, 'Contents', 'MacOS', command[:-4])
          out = open( scriptfile, 'w' )
          out.write( '''#!/bin/sh
  directory="$0"
  [ -L "$directory" ] && directory="`dirname "$directory"`/`readlink "$directory"`"
  command=`basename $directory`
  directory="`dirname $directory`"
  directory="`cd $directory/../../..;pwd`"
  if [ -x "$directory/bv_env" ]; then
    exec "$directory/bv_env" "$directory/real-bin/'''+command+'''/Contents/MacOS/$command" "$@"
  else
    exec "$directory/real-bin/'''+command+'''/Contents/MacOS/$command" "$@"
  fi
  ''' )
          out.close()
          os.chmod( scriptfile, os.stat( os.path.join(dest, 'Contents', 'MacOS', command[:-4]) ).st_mode )
        continue # other directories are left untouched

      
      if os.path.isfile( source ) and not os.path.islink( source ):
        dest = os.path.join( realbindir, command )
        if os.path.exists( dest ):
          os.remove( dest )
        os.rename( source, dest )
        if sys.platform == 'win32':
          ext = os.path.splitext(source)[1]
          if ext in ( '.py' ) :
            launcher = '\"python' + exe_ext + '\" '
          else :
            launcher = ''
          source = os.path.splitext(source)[0] + '.bat'
        out = open( source, 'w' )
        if sys.platform == 'win32':
          out.write( '''@setlocal
@set directory="%%~d0%%~p0"
@set command="%%~n0%(EXT)s"
@if exist "%%directory:~1,-1%%bv_env.exe" (
  @"%%directory:~1,-1%%bv_env.exe" %(LAUNCHER)s"%%directory:~1,-1%%real-bin\%%command:~1,-1%%" %%*
) else (
  @%(LAUNCHER)s"%%directory:~1,-1%%real-bin\%%command:~1,-1%%" %%*
)
@endlocal
  ''' % { 'EXT' : ext,
          'LAUNCHER' : launcher } )
        else :
          out.write( '''#!/bin/sh
  directory="$0"
  [ -L "$directory" ] && directory="`dirname "$directory"`/`readlink "$directory"`"
  command=`basename $directory`
  directory="`dirname $directory`"
  directory="`cd $directory;pwd`"
  if [ -x "$directory/bv_env" ]; then
    exec "$directory/bv_env" "$directory/real-bin/$command" "$@"
  else
    exec "$directory/real-bin/$command" "$@"
  fi
  ''' )
        out.close()
        os.chmod( source, os.stat( dest ).st_mode )
      elif os.path.islink(source):
        # copy the symlink into real-bin
        dest=os.readlink(source)
        os.symlink(dest, os.path.join(realbindir, os.path.basename(source)))
        
  # make easy shortcuts for BV and anatomist if they are packaged
  hasAnatomist = ("anatomist-free" in selected_packages) or ("anatomist-free" in dependencies)
  ana_shortcut = os.path.join(install_directory, "anatomist")
  hasBrainvisa = ("axon" in selected_packages) or ("axon" in dependencies)
  bv_shortcut = os.path.join(install_directory, "BrainVISA")
  # Windows
  if sys.platform[:3] == 'win':
    if hasAnatomist:
      ana_shortcut += ".bat"
      out = open( ana_shortcut, 'w' )
      out.write( '''@setlocal
@set directory="%~d0%~p0"
@call "%directory:~1,-1%bin\anatomist.bat" %*
@endlocal
  ''' )
      out.close()
    if hasBrainvisa:
      bv_shortcut += ".bat"
      out = open( bv_shortcut, 'w' )
      out.write( '''@setlocal
@set directory="%~d0%~p0"
@call "%directory:~1,-1%bin\brainvisa.bat" %*
@endlocal
  ''' )
      out.close()
  # Macos
  elif sys.platform[:6] == 'darwin':
    # Build MacOS X clickable icons
    if hasAnatomist:
      ana_shortcut += ".app"
      if os.path.exists( ana_shortcut ):
        os.unlink( anashortcut )
      os.symlink( os.path.join('bin', 'anatomist.app'), ana_shortcut )
    if hasBrainvisa:
      bv_shortcut += '.app'
      if os.path.exists( bv_shortcut ):
        shutil.rmtree( x, 1 )
      os.makedirs( os.path.join( bv_shortcut, 'Contents', 'MacOS' ) )
      os.makedirs( os.path.join( bv_shortcut, 'Contents', 'Resources' ) )
      os.symlink( '../../../bin/brainvisa', 
                  os.path.join( bv_shortcut, 'Contents', 
                                'MacOS', 'brainvisa' ) )
      icns = glob.glob( os.path.join( install_directory, 'share', 'brainvisa*' ) )
      if icns:
        icns = os.path.join( '../../../share', os.path.basename( icns[0] ), 
          'icons/brainvisa.icns' )
      os.symlink( icns, os.path.join( bv_shortcut, 'Contents', 
                  'Resources', 'brainvisa.icns' ) )
      f = open( os.path.join( bv_shortcut, 'Contents', 'PkgInfo' ), 'w' )
      print >> f, 'APPL????'
      f.close()
      f = open( os.path.join( bv_shortcut, 'Contents', 'Info.plist' ), 'w' )
      print >> f, '''<?xml version="1.0" encoding="UTF-8"?>
  <!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
  <plist version="1.0">
  <dict>
          <key>CFBundleExecutable</key>
          <string>brainvisa</string>
          <key>CFBundleIconFile</key>
          <string>brainvisa.icns</string>
          <key>CFBundleIdentifier</key>
          <string>brainvisa</string>
          <key>CFBundlePackageType</key>
          <string>APPL</string>
  </dict>
  </plist>'''
      f.close()
  # Linux
  else:
    if hasAnatomist:
      if os.path.exists( ana_shortcut ):
        os.unlink( ana_shortcut )
      os.symlink( os.path.join( 'bin', 'anatomist' ), ana_shortcut )
    if hasBrainvisa:
      if os.path.exists( bv_shortcut ):
        os.unlink( bv_shortcut )
      os.symlink( os.path.join('bin', 'brainvisa'), bv_shortcut )
      
      
  # Update brainvisa shared database
  if hasBrainvisa and ("brainvisa-share" in selected_packages):
    print "Updating BrainVISA shared database"
    os.system( bv_shortcut+" -b --setup" )

  if list_installed_paths:
    result = {}
    for path, package in  (( i[len(install_directory)+1:], j ) for i,j in installed_paths.iteritems() ):
      result.setdefault( package, [] ).append( path )
  else:
    result = None
  return result


def create_compressed_package( options, selected_packages, dependencies ):
  if not options.output:
    raise UserWarning( 'Ouput file name must be given for this command' )
  temp_directory = tempfile.mkdtemp()
  if options.packname:
    install_directory = os.path.join(temp_directory, os.path.basename(options.output))
    os.mkdir(install_directory)
  else:
    install_directory = temp_directory

  try:
    output = options.output
    options.output = install_directory
    create_directory_package( options, selected_packages, dependencies )
    options.output = output
    if sys.platform != 'win32': # compressing in tar.bz2 with tar
      output=output+".tar.bz2"
      print 'Compressing %s in %s' % (repr(install_directory), repr(output) )
      system_call( options, [ 'tar', 'jcf', unixstyle_path( output ) ] + os.listdir( temp_directory ), cwd=temp_directory )
    else: # compressing in zip with zipfile module
      output = output+".zip"
      print 'Compressing %s in %s' % (repr(install_directory), repr(output) )
      os.chdir(temp_directory)
      import zipfile
      zf = zipfile.ZipFile( output, 'w', zipfile.ZIP_DEFLATED )
      def _store( zf, file ):
        if os.path.isdir( file ):
          files = os.listdir( file )
          for f in files:
            _store( zf, os.path.join( file, f ) )
        else:
          #print 'zipping', file
          zf.write( file )
      for f in os.listdir(temp_directory):
        _store( zf, f )
      zf.close()

  finally:
    print 'Removing %s' % repr(temp_directory)
    shutil.rmtree( temp_directory )


def validDebianPackageName( package ):
  # Debian package names only accepts alphanumeric or +- characters
  return package.replace( '_', '-' )

def create_debian_packages( options, selected_packages, dependencies ):
  if not options.output:
    output = os.getcwd()
  else:
    output = options.output
  if not os.path.exists( output ):
    os.makedirs( output )
  # Looking for architecture using apt-config if possible
  architecture = re.search( r'APT::Architecture *\"([^\"]*)\";?',
    subprocess.Popen( ( 'apt-config', 'dump' ), stdout=subprocess.PIPE, stderr=subprocess.STDOUT ).communicate()[0] )
  if architecture:
    architecture = architecture.group(1)
  else:
    architecture = build_processor
  
  # Create temporary install directory
  install_directory = tempfile.mkdtemp()
  try:
    options.output = install_directory
    installed_paths = create_directory_package( options, selected_packages, dependencies, list_installed_paths=True )
    options.output = output
    debs_directory = os.path.join( install_directory, 'deb_packages' )
    os.mkdir( debs_directory )
    for package, paths in installed_paths.iteritems():
      package_info = packages_info[ package ]
      debian_name = validDebianPackageName( package )
      package_info[ 'debian_name' ] = debian_name
      deb_file = os.path.join( options.output, debian_name + '-' + package_info[ 'version' ] + '-' + build_system + '-' + architecture + '.deb' )
      print 'Creating package', deb_file
      deb_directory = os.path.join( debs_directory, package )
      os.mkdir( deb_directory )
      
      # Create Debian control file
      os.mkdir( os.path.join( deb_directory, 'DEBIAN' ) )
      control = open( os.path.join( deb_directory, 'DEBIAN', 'control' ), 'w' )
      print >> control, ('''Package: %(debian_name)s
Version: %(version)s
Maintainer: %(maintainer)s
Architecture: ''' + architecture + '''
Description: %(type)s package for BrainVISA component %(name)s.
Priority: optional
Section: multiverse/science''') % package_info
      dependencies = {}
      for dependency_type, dest_package, version_ranges, binary_independent  in packages_dependencies.get( package, () ):
        for version_range in version_ranges.split( ';' ):
          dependencies.setdefault( dependency_type, [] ).append( validDebianPackageName( dest_package ) + ( ' ( ' + version_range + ' )' if version_ranges else '' ) )
      for dependency_type in ( 'DEPENDS', 'RECOMMENDS', 'SUGGESTS', 'ENHANCES' ):
        deps = dependencies.get( dependency_type )
        if deps:
          print >> control, dependency_type.capitalize() + ':', ', '.join( deps )
      deps = dependencies.get( 'RECOMMENDS' )
      if deps:
        print >> control, 'Depends:', ', '.join( deps )
      control.close()

      # Move files installed for this package in deb_directory
      for path in paths:
        source = os.path.join( install_directory, path )
        if os.path.isfile( source ):
          p, f = os.path.split( path )
          dest_directory = os.path.join( deb_directory, 'usr', p )
          if not os.path.exists( dest_directory ):
            os.makedirs( dest_directory )
          os.rename( source, os.path.join( dest_directory, f ) )
      
      # Creating *.deb file
      try:
        system_call( options, ( 'dpkg', '--build', unixstyle_path( deb_directory ), unixstyle_path( deb_file ) ) )
      except subprocess.CalledProcessError:
        print >> sys.stderr, '\nDebian control file for %s' % package
        sys.stderr.write( open( control.name ).read() )
        raise
  finally:
    print 'Removing %s' % repr(install_directory)
    shutil.rmtree( install_directory )

commands = {
  'list': list_selected_packages,
  'dot': create_graphviz_dependencies,
  'dir': create_directory_package,
  'pack': create_compressed_package,
  'deb': create_debian_packages
}

if __name__ == '__main__':
  # Command line options cannot be parsed with optparse.OptionParser because
  # non-option values starting with '-' are not supported. So let's parse
  # options in the old way.
  class Empty:
    pass
  options = Empty()
  options.help = False
  options.output = None
  options.dependencies = True
  options.bv_env = False
  options.packname = False
  options.cmake = 'cmake'
  options.verbose = False
  
  usage = '''bv_packaging [options] <package_type> [ <selection_rule> ... ]

  This program is for the creation of packages and dependency graph for build directories.

  Package types:
    list: Only list selected packages
    dot: Create a Graphviz dependency graph for selected packages
    dir: Create a single directory containing all selected packages
    pack: Like "dir" but compress the result in a *.tar.bz2 archive
    deb: Create a debian package for each selected packages

  Selection rule:
    +<selection_pattern>: Adds all packages corresponding to the selection pattern
    -<selection_pattern>: Remove all packages corresponding to the selection pattern

  Selection pattern:
    <property>=<pattern>[,<property>=<pattern>...]: matc all packages where every selected property match the corresponding pattern
    <pattern>: equivalent to name=<pattern>

  Packages properties:
    name: Name of the package
    type: Type of the package
    version: Package version
    project: Name of the project containing the package.
    maintainer: Name of the maintainer of the package

  Package types:
    run: Runtime package
    dev: Development package
    doc: Documentation package
    usrdoc: User documentation package
    devdoc: Developper documentation package
    thirdparty: Package corresponding to a thirdparty project not compiled in the build directory

  Default selection rule:
    +type=run: select all 

  Examples:
    Create a dependency graph for runtime packages
      bv_packaging -o /tmp/dependency-run.dot dot
    
    Create a dependency graph for development packages
      bv_packaging -o /tmp/dependency-dev.dot dot +type=dev
    
    Create debian packages for all runtime packages in soma project
      bv_packaging deb +project=soma,type=run
      
    Create debian packages for all runtime packages except brainvisa-system:
      bv_packaging deb +type=run -name=brainvisa-system
    
    List all packages whose name start with "a" excludind development packages
    without their dependent packages:
      bv_packaging --no-deps list '+a*'

Options:
  -h, --help            Show this help message and exit
  -v, --verbose         Show verbose information
  -o OUTPUT, --output=OUTPUT
                        File (without extension) or directory where output will be stored.
  --no-deps             Do not include dependencies packages.
  --bv_env              Replace commands located in bin directory by a script that calls
                        the command through bv_env.
  --packname            Include the name of the package in the compressed archive. 
                        Available only with pack command. By default, the path in the archive are relative to the pack.
  --tmp DIRECTORY       Location of temporary directory (default is %(tmp)s).
  --cmake CMAKE_EXE     Location of cmake executable (default = %(cmake)s).
''' % { 'tmp': repr( tempfile.gettempdir() ),
        'cmake': repr( options.cmake ) }

  args = sys.argv[ 1: ]
  index = 0
  while index < len( args ):
    if args[ index ] in ( '-h', '--help' ):
      options.help = True
      print usage
      sys.exit( 0 )
    elif args[ index ] in ( '-v', '--verbose' ):
      options.verbose = True
      del args[ index ]
    elif args[ index ] in ( '-o', '--output' ):
      del args[ index ]
      if index == len( args ):
        print >> sys.stderr, 'Missing output file or directory name'
        sys.exit( 1 )
      options.output = args[ index ]
      del args[ index ]
    elif args[ index ] == '--no-deps':
      options.dependencies = False
      del args[ index ]
    elif args[ index ] == '--bv_env':
      options.bv_env = True
      del args[ index ]
    elif args[ index ] == '--packname':
      options.packname = True
      del args[ index ]
    elif args[ index ] == '--cmake':
      del args[ index ]
      if index == len( args ):
        print >> sys.stderr, 'Missing cmake location'
        sys.exit( 1 )
      options.cmake = args[ index ]
      del args[ index ]
    elif args[ index ] == '--tmp':
      del args[ index ]
      if index == len( args ):
        print >> sys.stderr, 'Missing temporary directory name'
        sys.exit( 1 )
      tempfile.tempdir = args[ index ]
      del args[ index ]
    else:
      index += 1
  
  if len( args ) < 1:
    print >> sys.stderr, 'No command given (use -h option to get help)'
    sys.exit( 1 )
  command = commands.get( args[ 0 ] )
  if command is None:
    print >> sys.stderr, 'Unknown command "%s" (use -h option to get help)' % args[0]
    sys.exit( 1 )
  
  try:
    packages, dependencies = packages_selection( args[ 1: ] )
    command( options, packages, dependencies )
  except Warning, e:
    print >> sys.stderr, str( e )
    sys.exit( 1 )
  
