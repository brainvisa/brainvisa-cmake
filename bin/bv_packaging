#!/usr/bin/env python
# -*- coding: utf-8 -*-

#  This software and supporting documentation are distributed by
#      Institut Federatif de Recherche 49
#      CEA/NeuroSpin, Batiment 145,
#      91191 Gif-sur-Yvette cedex
#      France
#
# This software is governed by the CeCILL-B license under
# French law and abiding by the rules of distribution of free software.
# You can  use, modify and/or redistribute the software under the
# terms of the CeCILL-B license as circulated by CEA, CNRS
# and INRIA at the following URL "http://www.cecill.info".
#
# As a counterpart to the access to the source code and  rights to copy,
# modify and redistribute granted by the license, users are provided only
# with a limited warranty  and the software's author,  the holder of the
# economic rights,  and the successive licensors  have only  limited
# liability.
#
# In this respect, the user's attention is drawn to the risks associated
# with loading,  using,  modifying and/or developing or reproducing the
# software by the user in light of its specific status of free software,
# that may mean  that it is complicated to manipulate,  and  that  also
# therefore means  that it is reserved for developers  and  experienced
# professionals having in-depth computer knowledge. Users are therefore
# encouraged to load and test the software's suitability as regards their
# requirements in conditions enabling the security of their systems and/or
# data to be ensured and,  more generally, to use and operate it in the
# same conditions as regards security.
#
# The fact that you are presently reading this means that you have had
# knowledge of the CeCILL-B license and that you accept its terms.

from __future__ import print_function
import sys
import os
import re
import fnmatch
import subprocess
import tempfile
import shutil
import glob
import time
import six
from stat import S_IRUSR, S_IXUSR, S_IRGRP, S_IXGRP, S_IROTH, S_IXOTH

if os.path.exists(sys.argv[0]):
    this_script = sys.argv[0]
else:
    this_script = None
    for p in os.environ.get('PATH', '').split(os.pathsep) + [os.curdir]:
        s = os.path.join(p, sys.argv[0])
        if os.path.exists(s):
            this_script = s
            break
if this_script:
    this_script = os.path.normpath(os.path.abspath(this_script))
    brainvisacmake_directory = os.path.dirname(os.path.dirname(this_script))
    python_modules = os.path.join(brainvisacmake_directory, 'python')
    if os.path.isdir(python_modules):
        sys.path.insert(0, python_modules)


from brainvisa.compilation_info import packages_info, packages_dependencies, build_directory, build_system, build_processor


def system_call(options, command, cwd=None, env=None, return_output=False):
    if options.verbose and not return_output:
        print()
        print('->', ' '.join((repr(i) for i in command)))
        print()
        stdout = None
        stderr = None
    else:
        stdout = subprocess.PIPE
        stderr = subprocess.STDOUT
    popen = subprocess.Popen(command,
                             stdout=stdout, stderr=stderr, cwd=cwd, env=env)
    result = popen.communicate()[0]
    if popen.returncode:
        print('-- failed command: --')
        print('-- command:', command)
        print('-- options:', options.__dict__)
        print('-- return code: %d, output: --' % popen.returncode)
        print(result)
        print('-- end of command outpput --')
        raise subprocess.CalledProcessError(
            popen.returncode, ' '.join((repr(i) for i in command)))
    elif options.verbose and stdout is not None:
        print(result)
    if return_output:
        return result


def system_path(path, mode='auto2win', keepdrive=True):

    if (mode == 'unix2win'
            or ((mode == 'auto2win') and (sys.platform[:3] != 'win'))):
        return path.replace('/', '\\')

    elif (mode == 'win2unix'
          or ((mode == 'auto2unix') and (sys.platform[:3] == 'win'))):
        if not keepdrive:
            # This is an absolute windows path
            path = os.path.sep + path.replace(':', '')

        return path.replace('\\', '/')

    return path


def recursive_listdir(directory):
    for i in os.listdir(directory):
        item = os.path.join(directory, i)
        yield item
        if os.path.isdir(item):
            for j in recursive_listdir(item):
                yield j


def packages_selection(rules):
    if not rules:
        rules = ['+type=run', '-project=thirdparty']
    packages = set()
    for rule in rules:
        if not rule:
            continue
        if rule[0] in ('+', '-'):
            if rule[1:] == 'dependencies':
                # Complete packages with dependencies of currently selected
                # packages
                dependencies = set()
                todo = set(packages)
                while todo:
                    package = todo.pop()
                    for type, name, version, binary_independent in packages_dependencies.get(package, ()):
                        if name not in packages and name not in dependencies:
                            dependencies.add(name)
                            todo.add(name)
                packages.update(dependencies)
            else:
                attributes = {}
                for attribute_selection in rule[1:].split(','):
                    if not attribute_selection:
                        continue
                    try:
                        attribute, pattern = attribute_selection.split('=', 1)
                    except ValueError:
                        attribute = 'name'
                        pattern = attribute_selection
                    attributes[attribute] = re.compile(
                        fnmatch.translate(pattern))
                for package_info in packages_info.itervalues():
                    selected = True
                    for attribute, pattern in six.iteritems(attributes):
                        value = package_info.get(attribute)
                        if value is None:
                            raise SyntaxWarning(
                                'Unknown attribute %s in rule %s' % (repr(attribute), repr(rule)))
                        if not pattern.match(value):
                            selected = False
                            break
                    if selected:
                        if rule[0] == '+':
                            packages.add(package_info['name'])
                        else:
                            packages.discard(package_info['name'])
        else:
            raise SyntaxWarning(
                'A package selection rule must start with + or -: %s' % repr(rule))

        dependencies = set()
        todo = set(packages)
        while todo:
            package = todo.pop()
            for type, name, version, binary_independent in packages_dependencies.get(package, ()):
                if name not in packages and name not in dependencies:
                    dependencies.add(name)
                    todo.add(name)

    # brainvisa-release component must be install after all other components,
    # so packages is converted into a list and brainvisa-release moved at the
    # end of that list.
    if ("brainvisa-release" in packages):
        packages.remove("brainvisa-release")
        packages = list(packages)
        packages.append("brainvisa-release")
    else:
        packages = list(packages)
    dependencies = list(dependencies)
    return (packages, dependencies)


def list_selected_packages(options, selected_packages, dependencies):
    if options.output is None:
        out = sys.stdout
    else:
        out = open(options.output, 'w')
    if options.dependencies and dependencies:
        print('Selected packages:', file=out)
        indent = '  '
    else:
        indent = ''
    print(indent + ('\n' + indent).join(selected_packages), file=out)
    if options.dependencies and dependencies:
        print('\nDependencies packages:', file=out)
        print('  ' + '\n  '.join(dependencies), file=out)


def create_graphviz_dependencies(options, selected_packages, dependencies):
    if options.output is None:
        out = sys.stdout
    else:
        out = open(options.output, 'w')
    nodes = {}
    print('digraph packages_dependencies {', file=out)
    done = set()
    todo = selected_packages
    while todo:
        source_package = todo.pop(0)
        if source_package in done:
            continue
        done.add(source_package)
        source_package = packages_info[source_package]
        source_node = nodes.get(source_package['name'])
        if source_node is None:
            source_node = str(len(nodes))
            nodes[source_package['name']] = source_node
            if source_package['project'] == 'thirdparty':
                print('  %s [ label="%s", color=orange ]' % (
                      source_node, source_package['name']), file=out)
            else:
                print('  %s [ label="%s" ]' % (
                      source_node, source_package['name']), file=out)
        for dependency_type, dest_package, version_ranges, binary_independent in packages_dependencies.get(source_package['name'], ()):
            if not options.dependencies and dest_package not in selected_packages:
                continue
            todo.append(dest_package)
            dest_package = packages_info[dest_package]
            dest_node = nodes.get(dest_package['name'])
            if dest_node is None:
                dest_node = str(len(nodes))
                nodes[dest_package['name']] = dest_node
                if dest_package['project'] == 'thirdparty':
                    print('  %s [ label="%s", color=orange ]' % (
                          dest_node, dest_package['name']), file=out)
                else:
                    print('  %s [ label="%s" ]' % (
                          dest_node, dest_package['name']), file=out)
            if dependency_type == 'DEPENDS':
                color = 'black'
            elif dependency_type == 'RECOMMENDS':
                color = 'green'
            else:
                color = 'blue'
            print('  %s -> %s [ color=%s ]' % (
                  source_node, dest_node, color), file=out)
    print('}', file=out)


def is_shell_script(filename):
    try:
        f = open(filename)
        l = f.readline().strip()
        shells = ('#!/bin/sh', '#! /bin/sh', '#!/bin/bash', '#! /bin/bash')
        for shell in shells:
            if l.startswith(shell):
                return True
    except:
        return False
    return False


def create_directory_package(options, selected_packages, dependencies,
                             list_installed_paths=False):

    if not options.output:
        raise UserWarning('Ouput directory must be given for this command')
    install_directory = options.output
    if not os.path.exists(install_directory):
        os.makedirs(install_directory)
    else:
        if list_installed_paths and os.listdir(install_directory):
            raise UserWarning(
                'This command cannot be done on an existing and non empty directory: %s' % repr(install_directory))
    installed_paths = {}
    current_dir = os.getcwd()
    os.chdir(build_directory)
    
    hasAnatomist = ("anatomist-free" in selected_packages) \
        or (options.dependencies and ("anatomist-free" in dependencies))
    hasBrainvisa = ("axon" in selected_packages) \
        or (options.dependencies and ("axon" in dependencies))
    hasMorphologistUI = ("morphologist-ui" in selected_packages) \
        or (options.dependencies and ("morphologist-ui" in dependencies))
    hasBVShare = "brainvisa-share" in selected_packages \
        or (options.dependencies and "brainvisa-share" in dependencies)

    for package in (selected_packages + dependencies
                    if options.dependencies else selected_packages):
        print('Installing', package)
        install_cmd_name = 'install-' + packages_info[package]['component']
        if package == 'brainvisa-release' and options.installer:
            install_cmd_name = 'install-brainvisa-release_installer_doc'
        command = ['make']
        
        if options.make_options is not None \
            and len(options.make_options.strip()) > 0:
            command += eval(options.make_options, None, None).split()
        
        command += ['BRAINVISA_INSTALL_PREFIX=' + system_path(
                   install_directory, 'auto2unix'), install_cmd_name]
        system_call(options, command)
        if list_installed_paths:
            # List files installed by package
            for i in (j for j in recursive_listdir(install_directory)
                      if j not in installed_paths):
                installed_paths[i] = package

    # patch linux packaged libraries to remove rpaths
    if (options.platform_target[:3] != "win"
            and options.platform_target[:6] != "darwin"
            and options.platform_target != "osx"
            and options.dependencies):
        if os.path.exists(os.path.join(install_directory, "lib")):
            print("Trying to remove RPATH from packaged libraries headers")
            os.chdir(os.path.join(install_directory, "lib"))
            patch_output = system_call(
                options, ["bv_patch_libs.sh"], return_output=True)
            print(patch_output)
    os.chdir(current_dir)

    # create scripts that call bv_env before calling the command to setup
    # environment variables
    if options.bv_env or options.wrappers:

        # Extensions for which scripts command are not generated
        config_ext = ['.conf']

        bindir = os.path.join(install_directory, 'bin')
        if not os.path.exists(bindir):
            os.mkdir(bindir)
        specific_env_commands = list()
        if options.platform_target[:3] == 'win':
            exe_ext = '.exe'
            if hasBrainvisa:
                specific_env_commands += ['brainvisa']
        else:
            exe_ext = ''
        env_commands = ['bv_env' + exe_ext, 'bv_env.py',
                        'bv_env.sh', 'bv_env_test', 'bv_env.bat', 'bv_unenv',
                        'bv_unenv.sh']
        if options.bv_env:  # --bv_env case: also install bv_env* commands
            specific_env_commands += env_commands
        for command in specific_env_commands:
            source = os.path.join(brainvisacmake_directory, 'bin', command)
            dest = os.path.join(bindir, command)
            if os.path.exists(dest):
                os.remove(dest)
            shutil.copy(source, dest)
            os.chmod(dest, os.stat(source).st_mode)
        commands = [c for c in os.listdir(bindir) if c not in env_commands]
        if len(commands) != 0:
            realbindir = os.path.join(bindir, 'real-bin')
            if not os.path.exists(realbindir):
                os.mkdir(realbindir)
        for command in commands:
            if command in specific_env_commands:
                continue
            source = os.path.join(bindir, command)

            if os.path.isdir(source):
                if command[-4:] == '.app':  # MacOS GUI commands
                    dest = os.path.join(realbindir, command)
                    # first move the entire tree
                    if not os.path.exists(dest):
                        os.rename(source, dest)
                    elif os.path.exists(source):
                        shutil.rmtree(source)
                    # then recreate it
                    os.mkdir(source)
                    os.mkdir(os.path.join(source, 'Contents'))
                    os.mkdir(os.path.join(source, 'Contents', 'MacOS'))
                    if os.path.exists(os.path.join(dest, 'Contents',
                                                   'Info.plist')):
                        os.symlink(
                            os.path.join('../../real-bin', command, 'Contents',
                                         'Info.plist'),
                                    os.path.join(source, 'Contents',
                                                 'Info.plist'))
                    if os.path.exists(os.path.join(dest, 'Contents',
                                                   'PkgInfo')):
                        os.symlink(
                            os.path.join('../../real-bin', command, 'Contents',
                                         'PkgInfo'),
                                    os.path.join(source, 'Contents',
                                                 'PkgInfo'))
                    icns = os.path.join(
                        'Contents', 'Resources', command[:-4] + '.icns')
                    if os.path.exists(os.path.join(dest, icns)):
                        os.mkdir(
                            os.path.join(source, 'Contents', 'Resources'))
                        os.symlink(
                            os.path.join('../../../real-bin', command, icns),
                                    os.path.join(source, icns))
                    bapp = command[:-4].lower()
                    bappsrc = os.path.join(bindir, bapp)
                    bappdst = os.path.join(realbindir, command[:-4])
                    if os.path.islink(bappsrc):
                        if os.path.exists(bappdst) or os.path.islink(bappdst):
                            os.unlink(bappdst)
                        os.symlink(os.readlink(bappsrc), bappdst)
                    # Generate the script
                    scriptfile = os.path.join(
                        source, 'Contents', 'MacOS', command[:-4])
                    out = open(scriptfile, 'w')
                    out.write( '''#!/bin/sh
  directory="$0"
  [ -L "$directory" ] && directory="`dirname \\"$directory\\"`/`readlink \\"$directory\\"`"
  command="`basename \\"$directory\\"`"
  directory="`dirname \\"$directory\\"`"
  directory="`cd \\"$directory/../../..\\";pwd`"
  if [ -x "$directory/bv_env" ]; then
    exec "$directory/bv_env" "$directory/real-bin/''' + command + '''/Contents/MacOS/$command" "$@"
  else
    exec "$directory/real-bin/''' + command + '''/Contents/MacOS/$command" "$@"
  fi
  ''' )
                    out.close()
                    os.chmod(scriptfile, os.stat(
                        os.path.join(dest, 'Contents', 'MacOS', command[:-4])).st_mode)
                continue  # other directories are left untouched

            if os.path.isfile(source) and not os.path.islink(source):
                dest = os.path.join(realbindir, command)
                if os.path.exists(dest):
                    os.remove(dest)
                os.rename(source, dest)

                # Only generate scripts for files that are not configuration
                # files
                ext = os.path.splitext(command)[1]
                if not ext in config_ext:
                    if options.platform_target[:3] == 'win':
                        if ext in ('.py'):
                            launcher = '\"python.exe\" '
                            ext = ''
                            source = source + '.bat'
                            realcommand = "%directory:~1,-1%real-bin\\%command:~1,-1%"
                        elif (command == "brainvisa.bat"):
                            # calling a .bat script via bv_env doesn't seem to
                            # work, so for brainvisa, directly call python
                            # neuro.py
                            launcher = '\"python.exe\" '
                            realcommand = "%directory:~1,-1%..\\brainvisa\\neuro.py"
                        else:
                            launcher = ''
                            source = os.path.splitext(source)[0] + '.bat'
                            realcommand = "%directory:~1,-1%real-bin\\%command:~1,-1%"
                    out = open(source, 'w')

                    if options.platform_target[:3] == 'win':
                        out.write( '''@setlocal
@set directory="%%~d0%%~p0"
@set command="%%~n0%(EXT)s"
@if exist "%%directory:~1,-1%%bv_env.exe" (
  @"%%directory:~1,-1%%bv_env.exe" %(LAUNCHER)s"%(REALCOM)s" %%*
) else (
  @%(LAUNCHER)s"%(REALCOM)s" %%*
)
@endlocal
  ''' % { 'EXT' : ext,
          'LAUNCHER': launcher,
          'REALCOM': realcommand})

                    elif options.platform_target[:6] == 'darwin' \
                            or options.platform_target == 'osx':
                        if is_shell_script(dest):
                            # avoir running a sub-shell
                            out.write( '''#!/bin/sh
  directory="$0"
  [ -L "$directory" ] && directory="`dirname \\"$directory\\"`/`readlink \\"$directory\\"`"
  command="`basename \\"$directory\\"`"
  directory="`dirname \\"$directory\\"`"
  directory="`cd \\"$directory\\";pwd`"
  if [ -x "$directory/bv_env.sh" ]; then
    . "$directory/bv_env.sh" "`dirname \\"$directory\\"`"
    . "$directory/real-bin/$command" "$@"
  else
    . "$directory/real-bin/$command" "$@"
  fi
  ''')
                        else:  # Mac / not a shell script
                            out.write( '''#!/bin/sh
  directory="$0"
  [ -L "$directory" ] && directory="`dirname \\"$directory\\"`/`readlink \\"$directory\\"`"
  command="`basename \\"$directory\\"`"
  directory="`dirname \\"$directory\\"`"
  directory="`cd \\"$directory\\";pwd`"
  if [ -x "$directory/bv_env" ]; then
    exec "$directory/bv_env" "$directory/real-bin/$command" "$@"
  else
    exec "$directory/real-bin/$command" "$@"
  fi
  ''' )

                    else:  # linux
                        out.write( '''#!/bin/sh
  directory="$0"
  [ -L "$directory" ] && directory="`readlink -f \\"$directory\\"`"
  command="`basename \\"$directory\\"`"
  directory="`dirname \\"$directory\\"`"
  directory="`cd \\"$directory\\";pwd`"
  if [ -x "$directory/bv_env" ]; then
    exec "$directory/bv_env" "$directory/real-bin/$command" "$@"
  else
    exec "$directory/real-bin/$command" "$@"
  fi
  ''' )
                    out.close()
                    os.chmod(source, os.stat(dest).st_mode)
            elif os.path.islink(source):
                # copy the symlink into real-bin
                dest = os.readlink(source)
                real_dest = os.path.join(realbindir, os.path.basename(source))
                if os.path.exists(real_dest) or os.path.islink(real_dest):
                    os.unlink(real_dest)
                os.symlink(dest, real_dest)

    # make easy shortcuts for BV and anatomist if they are packaged
    root_shortcuts = []
    ana_shortcut = os.path.join(install_directory, "anatomist")
    if hasAnatomist:
        root_shortcuts.append(
            [ana_shortcut, "anatomist", False])  # False is not script
    bv_shortcut = os.path.join(install_directory, "BrainVISA")
    if hasBrainvisa:
        root_shortcuts.append(
            [bv_shortcut, "brainvisa", True])  # True is script
    morpho_shortcut = os.path.join(install_directory, "morphologist")
    if hasMorphologistUI:
        root_shortcuts.append([morpho_shortcut, "morphologist", True])
    # Windows
    if options.platform_target[:3] == 'win':
        for shortcut, exe_name, is_script in root_shortcuts:
            shortcut += ".bat"
            out = open(shortcut, 'w')
            out.write( '''@setlocal
@set directory="%~d0%~p0"
@call "%directory:~1,-1%bin\\''' + exe_name + '''.bat" %*
@endlocal
  ''' )
            out.close()

    # Macos
    elif options.platform_target[:6] == 'darwin' \
          or options.platform_target == 'osx':
        # Build MacOS X clickable icons
        for shortcut, exe_name, is_script in root_shortcuts:
            if not is_script:
                shortcut += ".app"
                if os.path.exists(shortcut) or os.path.islink(shortcut):
                    os.unlink(shortcut)
                os.symlink(os.path.join('bin', '%s.app' % exe_name), shortcut)
            else:
                shortcut += '.app'
                if os.path.exists(shortcut) or os.path.islink(shortcut):
                    shutil.rmtree(shortcut, 1)
                os.makedirs(os.path.join(shortcut, 'Contents', 'MacOS'))
                os.makedirs(os.path.join(shortcut, 'Contents', 'Resources'))
                os.symlink('../../../bin/%s' % exe_name,
                           os.path.join(shortcut, 'Contents', 'MacOS', exe_name))
                icns = glob.glob(
                    os.path.join(install_directory, 'share', 'axon*'))
                if icns:
                    icns = os.path.join(
                        '../../../share', os.path.basename(icns[0]),
                      'icons/brainvisa.icns')
                    os.symlink(icns, os.path.join(shortcut, 'Contents',
                                                  'Resources', '%s.icns' % exe_name))
                f = open(os.path.join(shortcut, 'Contents', 'PkgInfo'), 'w')
                print('APPL????', file=f)
                f.close()
                f = open(
                    os.path.join(shortcut, 'Contents', 'Info.plist'), 'w')
                print('''<?xml version="1.0" encoding="UTF-8"?>
  <!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
  <plist version="1.0">
  <dict>
          <key>CFBundleExecutable</key>
          <string>%s</string>
''' % exe_name, file=f)
                if icns:
                    print('''          <key>CFBundleIconFile</key>
          <string>%s.icns</string>
''' % exe_name, file=f)
                print('''          <key>CFBundleIdentifier</key>
          <string>%s</string>
          <key>CFBundlePackageType</key>
          <string>APPL</string>
  </dict>
  </plist>''' % exe_name, file=f)
                f.close()

        if hasBrainvisa:
            bv_shortcut = os.path.join(bv_shortcut, 'Contents', 'MacOS',
                                       'brainvisa')

    else:
        # Linux
        for shortcut, exe_name, is_script in root_shortcuts:
            if os.path.exists(shortcut) or os.path.islink(shortcut):
                os.unlink(shortcut)
            os.symlink(os.path.join('bin', exe_name), shortcut)

    # Update brainvisa shared database
    if hasBVShare:
        print("Updating BrainVISA shared database")
        try:
            if options.platform_target[:3] == 'win':
                cmd = [os.path.join(brainvisacmake_directory, 
                                    'bin', 'bv_env.exe'),
                       'python.exe',
                       os.path.join(brainvisacmake_directory, 
                                    'brainvisa', 'neuro.py'), 
                       '-b', '--setup']
            else:
                cmd = [os.path.join(brainvisacmake_directory, 'bin', 'bv_env'),
                       'brainvisa', '-b', '--setup']
            print('running:', ' '.join(cmd))
            subprocess.check_call(cmd)
            print('update done.')
            share_conf = os.path.join(brainvisacmake_directory, 'python',
                                      'brainvisa_share', 'config.py')
            if os.path.exists(share_conf):
                share_c = {}
                execfile(share_conf, share_c)
                share_path = os.path.join(brainvisacmake_directory, 'share',
                                          share_c['share'])
                files = glob.glob(
                    os.path.join(share_path, 'database-*.sqlite'))
                if files:
                    files = [files[-1], files[-1] + '.minf']
                files += [os.path.join(share_path, 'database_fso.html'),
                          os.path.join(share_path, 'database_fso.html.minf')]
                share_inst_dir = os.path.join(install_directory, 'share',
                                              share_c['share'])
                for f in files:
                    if os.path.exists(f):
                        outf = os.path.join(
                            share_inst_dir, os.path.basename(f))
                        shutil.copyfile(f, outf)
                        os.chmod(outf, 0666)
        except Exception as e:
            print('database update / copy failed:')
            print(e)
            print('(ignored)')

    # create a .README file with install / run instrutctions
    create_readme_file(install_directory)

    if list_installed_paths:
        result = {}
        for path, package in ((i[len(install_directory) + 1:], j) for i, j in six.iteritems(installed_paths)):
            result.setdefault(package, []).append(path)
    else:
        result = None
    return result


def create_compressed_package(options, selected_packages, dependencies):
    if not options.output:
        raise UserWarning('Ouput file name must be given for this command')
    # on windows the size of filename is limited, so brainvisa pack cannot be installed in a too long path
    # and default tmp directory is too long, so use c:/tmp if it exists
    # instead of default tmp directory
    if ((sys.platform[:3] == 'win') and (os.path.exists("c:/tmp"))):
        temp_directory = tempfile.mkdtemp(dir="c:/tmp")
    else:
        temp_directory = tempfile.mkdtemp()

    if len(options.compressedpackdir) > 0:
        install_directory = os.path.join(
            temp_directory, options.compressedpackdir)
        os.mkdir(install_directory)
    else:
        install_directory = os.path.join(
            temp_directory, os.path.basename(options.output))
        os.mkdir(install_directory)

    try:
        output = options.output
        options.output = install_directory
        create_directory_package(options, selected_packages, dependencies)
        options.output = output
        if options.platform_target[:3] != 'win':  # compressing in tar.bz2 with tar
            output = output + ".tar.bz2"
            print('Compressing %s in %s' % (repr(install_directory),
                                            repr(output)))
            system_call(
                options, ['tar', 'jcf', system_path(output, 'auto2unix'), os.path.basename(install_directory)], cwd=temp_directory)
        else:  # compressing in zip with zipfile module
            output = output + ".zip"
            print('Compressing %s in %s' % (repr(install_directory),
                                            repr(output)))
            os.chdir(temp_directory)
            import zipfile
            zf = zipfile.ZipFile(output, 'w', zipfile.ZIP_DEFLATED)

            def _store(zf, file):
                if os.path.isdir(file):
                    files = os.listdir(file)
                    for f in files:
                        _store(zf, os.path.join(file, f))
                else:
                    # print('zipping', file)
                    zf.write(file)
            _store(zf, os.path.basename(install_directory))
            zf.close()
        # copy readme file outside the temp directory
        shutil.copy(install_directory + '.README', options.output + '.README')
    finally:
        print('Removing %s' % repr(temp_directory))
        os.chdir(os.path.dirname(temp_directory))
        shutil.rmtree(temp_directory)


def create_readme_file(install_directory):
    if options.platform_target[:3] != 'win':
        zipext = ".tar.bz2"
    else:
        zipext = ".zip"
    date = time.strftime('%Y_%m_%d')
    m = re.match('.*-([0-9]\.[0-9](\.[0-9]))',
                 os.path.basename(install_directory))
    if m and len(m.groups()) >= 1:
        version = m.group(1)
    else:
        version = '<unknown>'
    packname = os.path.basename(install_directory)
    zfile = packname + zipext
    readme = open(install_directory + '.README', 'w')
    print('''                            BRAINVISA / ANATOMIST
                            INSTALL INSTRUCTIONS

Pack Version : ''' + version + '''
Release date : ''' + date + '''


####################
# INSTALLATION

1) cd to the directory where to install the top directory of
   the BrainVISA package, e.g.:

  cd /home/yourlogin

  (or maybe 'cd /usr/local' if you are root)


2) uncompress the archive file:

  On Unix : tar jxvf ''' + zfile + '''
  On Windows: uncompress the ZIP archive wherever you want to install the package


3) Optionally, change the main direcory name, e.g:

  mv ''' + packname + ''' brainvisa

4) The file ''' + zfile + ''' is not longer
   needed (except if you want to reinstall), and can be deleted.

-- Note that there is no setup program or script anymore: no setup step is
   needed now, and the binary package can be moved to a different directory
   afterwards: no absolute path is stored anywhere.

#####################
# RUNNING

The package consists of two main programs, anatomist and brainvisa, and a suite
of utility programs. All are located in the 'bin' directory of the package.

It is *not recommended* to permanently add this directory to your path,
because this can create conflicts with other programs on your system (e.g.
python). We suggest two possibilities.


1. To start a program, type the full path along with the name of the program,
   e.g.:

~/''' + packname + '''/bin/anatomist

(or create symbolic links to 'anatomist' and 'brainvisa' in a directory listed
in your path (maybe /home/yourlogin/bin)

2. If you often launch anatomist, brainvisa or the accompanying programs.
you can run a small shell script that modifies the paths and other shell
variables before each working session. You need to run:


On Linux or MacOS:
  . ./''' + packname + '''/bin/bv_env.sh ./''' + packname + '''

On Windows:

  ./''' + packname + '''/bin/bv_env.bat ./''' + packname + '''


To avoid typing this long line, Bash users may add the following four
lines to the '~/.bashrc' file:

function brainvisa_setup
{
 . ~/''' + packname + '''/bin/bv_env.sh ~/''' + packname + '''
}

Then typing 'brainvisa_setup' (completion works) will initialize the
variables and allow you to use the various commands from any place.


########################
# UNINSTALLING

To delete brainvisa from your system, just remove the whole
brainvisa directory (with 'rm -rf ''' + packname + '''')


########################
# PROBLEMS OR QUESTIONS


- Visit http://www.brainvisa.info web site.

- If you have 3D rendering problems on Linux in Anatomist, there may be an
  alternative OpenGL library in the present package. You have to copy it to the
  libraries directory to use it:

cp ''' + packname + '''/lib/mesa/libGL.so.1 ''' + packname + '''/lib/libGL.so.1

Then restart Anatomist.

It is a software-only Mesa-OpenGL library which is probably slower than the native OpenGL library on your machine, but which should at least work correctly in every case. you can remove it if you want to use the system OpenGL library again.

There are also two options in Anatomist preferences (in the OpenGL tab) that
might influence the rendering (which proved useful on some Windows machines):
- limit the number of texture units (it fixed a problem where nothing did display
  on one machine by setting the limit to 3)
- disable the use of OpenGL selection (it avoided crashes when the selection
  takes place on the same machine)

On Windows you can also lower the level of 3D hardware acceleration in the display properties of Windows, it quite often helps to bypass hardware driver
bugs.
''', file=readme)
    readme.close()
    shutil.copyfile(install_directory + '.README',
                    os.path.join(install_directory, "README"))


def validDebianPackageName(package):
    # Debian package names only accepts alphanumeric or +- characters
    return package.replace('_', '-')


def create_debian_packages(options, selected_packages, dependencies):
    if not options.output:
        output = os.getcwd()
    else:
        output = options.output
    if not os.path.exists(output):
        os.makedirs(output)
    # Looking for architecture using apt-config if possible
    architecture = re.search(r'APT::Architecture *\"([^\"]*)\";?',
                             subprocess.Popen(('apt-config', 'dump'), stdout=subprocess.PIPE, stderr=subprocess.STDOUT).communicate()[0])
    if architecture:
        architecture = architecture.group(1)
    else:
        architecture = build_processor

    # Loading json dictionary for system dependent package name
    import brainvisa.maker
    import json
    pkgDic = {}
    jsonPath = os.path.dirname( brainvisa.maker.__file__ )
    jsonFile = os.path.join( jsonPath, 'bv_dependencies_' + build_system + '.json' )
    if os.path.isfile( jsonFile ):
        pkgDic = json.load( open( jsonFile ) )

    # Create temporary install directory
    install_directory = tempfile.mkdtemp()
    try:
        options.output = install_directory
        installed_paths = create_directory_package(
            options, selected_packages, dependencies, list_installed_paths=True)
        options.output = output
        debs_directory = os.path.join(install_directory, 'deb_packages')
        os.mkdir(debs_directory)
        for package, paths in six.iteritems(installed_paths):
            package_info = packages_info[package]
            debian_name = validDebianPackageName(package)
            package_info['debian_name'] = debian_name
            deb_file = os.path.join(options.output, debian_name + '-' + package_info[
                                    'version'] + '-' + build_system + '-' + architecture + '.deb')
            print('Creating package', deb_file)
            deb_directory = os.path.join(debs_directory, package)
            os.mkdir(deb_directory)

            # Create Debian control file
            os.mkdir(os.path.join(deb_directory, 'DEBIAN'))
            control = open(
                os.path.join(deb_directory, 'DEBIAN', 'control'), 'w')
            print(('''Package: %(debian_name)s
Version: %(version)s
Maintainer: %(maintainer)s
Architecture: ''' + architecture + '''
Description: %(type)s package for BrainVISA component %(name)s.
Priority: optional
Section: multiverse/science''') % package_info, file=control)
            dependencies = {}
            for dependency_type, dest_package, version_ranges, binary_independent in packages_dependencies.get(package, ()):
                deb_package = { "name": dest_package, "version": version_ranges }
                if dest_package in pkgDic:
                    deb_package = pkgDic[ dest_package ]
                if len( deb_package[ "name" ] ) > 0:
                    deb_name = deb_package[ "name" ]
                    deb_version_ranges = deb_package[ "version" ]
                    print(dependency_type, deb_name, deb_version_ranges,
                          binary_independent)
                    for version_range in deb_version_ranges.split(';'):
                        dependencies.setdefault(dependency_type, []).append(validDebianPackageName(
                            deb_name ) + (' ( ' + version_range + ' )' if deb_version_ranges else ''))
            for dependency_type in ('DEPENDS', 'RECOMMENDS', 'SUGGESTS', 'ENHANCES'):
                deps = dependencies.get(dependency_type)
                if deps:
                    print(dependency_type.capitalize() + ':',
                          ', '.join(deps), file=control)
            # deps = dependencies.get( 'RECOMMENDS' )
            # if deps:
                # print('Depends:', ', '.join( deps ), file=control)
            control.close()

            # Remove invalid files and links
            valid_paths = []
            for path in paths:
                source = os.path.join(install_directory, path)
                if os.path.isfile(source):
                    valid_paths.append(path)

            # Move valid files and links installed for this package in deb_directory
            for path in valid_paths:
                source = os.path.join(install_directory, path)
                p, f = os.path.split(path)
                dest_directory = os.path.join(deb_directory, 'usr', p)
                if not os.path.exists(dest_directory):
                    os.makedirs(dest_directory)
                os.rename(source, os.path.join(dest_directory, f))

            # Creating *.deb file
            try:
                system_call(options, ('dpkg', '--build', system_path(
                    deb_directory, 'auto2unix'), system_path(deb_file, 'auto2unix')))
            except subprocess.CalledProcessError:
                print('\nDebian control file for %s' % package,
                      file=sys.stderr)
                sys.stderr.write(open(control.name).read())
                raise
    finally:
        print('Removing %s' % repr(install_directory))
        os.chdir(os.path.dirname(install_directory))
        shutil.rmtree(install_directory)

commands = {
  'list': list_selected_packages,
  'dot': create_graphviz_dependencies,
  'dir': create_directory_package,
  'pack': create_compressed_package,
  'deb': create_debian_packages
}

if __name__ == '__main__':
    # Command line options cannot be parsed with optparse.OptionParser because
    # non-option values starting with '-' are not supported. So let's parse
    # options in the old way.
    class Empty:
        pass
    options = Empty()
    options.help = False
    options.output = None
    options.dependencies = True
    options.bv_env = False
    options.wrappers = False
    options.packname = True
    options.compressedpackdir = ''
    options.cmake = 'cmake'
    options.verbose = False
    options.installer = False
    options.make_options = None
    options.platform_target = sys.platform

    usage = '''bv_packaging [options] <package_type> [ <selection_rule> ... ]

  This program is for the creation of packages and dependency graph for build directories.

  Package types:
    list: Only list selected packages
    dot: Create a Graphviz dependency graph for selected packages
    dir: Create a single directory containing all selected packages
    pack: Like "dir" but compress the result in a *.tar.bz2 archive
    deb: Create a debian package for each selected packages

  Selection rule:
    +<selection_pattern>: Adds all packages corresponding to the selection pattern
    -<selection_pattern>: Remove all packages corresponding to the selection pattern
    +dependencies: Special rule to add the dependencies of the currently selected packages

  Selection pattern:
    <property>=<pattern>[,<property>=<pattern>...]: match all packages where every selected property match the corresponding pattern
    <pattern>: equivalent to name=<pattern>

  Packages properties:
    name: Name of the package
    type: Type of the package
    version: Package version
    project: Name of the project containing the package.
    maintainer: Name of the maintainer of the package

  Package types:
    run: Runtime package
    dev: Development package
    doc: Documentation package
    usrdoc: User documentation package
    devdoc: Developper documentation package
    test: Test files package
    thirdparty: Package corresponding to a thirdparty project not compiled in the build directory

  Default selection rule:
    +type=run: select all

  Examples:
    Create a dependency graph for runtime packages
      bv_packaging -o /tmp/dependency-run.dot dot

    Create a dependency graph for development packages
      bv_packaging -o /tmp/dependency-dev.dot dot +type=dev

    Create debian packages for all runtime packages in soma project
      bv_packaging deb +project=soma,type=run

    Create debian packages for all runtime packages except brainvisa-system:
      bv_packaging deb +type=run -name=brainvisa-system

    List all packages whose name start with "a" excludind development packages
    without their dependent packages:
      bv_packaging --no-deps list '+a*'

    Create debian packages for all packages in soma project with all their dependencies except python
      bv_packaging deb +project=soma +dependencies -python


Options:
  -h, --help            Show this help message and exit
  -v, --verbose         Show verbose information
  -o OUTPUT, --output=OUTPUT
                        File (without extension) or directory where output will be stored.
  -m MAKE_OPTIONS, --make-options=MAKE_OPTIONS
                        Options to pass to make during packages creation.
  --bv_env              Replace commands located in bin directory by a script that calls
                        the command through bv_env.
  --wrappers            same as --bv_env, but do not copy the executable bv_env
                        and sibling scripts in the package directory: just do
                        the wrapping scripts
  --packname            Obsolete. Does nothing. Now the name of the package is always
                        included in the compressed archive.
  --compressed-packdir  Name of the directory in compressed archive.
                        Available only with pack command. By default, the name of the directory in the archive is the name of the pack.
  --tmp DIRECTORY       Location of temporary directory (default is %(tmp)s).
  --cmake CMAKE_EXE     Location of cmake executable (default = %(cmake)s).
  --installer           bv_packaging is used for the bv_build_installer tool:
                        changes only the way the brainvisa-release component
                        is installed.
  --platform-target PLATFORM
                        platform target for cross compilation.
''' % { 'tmp': repr( tempfile.gettempdir() ),
       
        'cmake': repr(options.cmake)}

    args = sys.argv[1:]
    index = 0
    while index < len(args):
        if args[index] in ('-h', '--help'):
            options.help = True
            print(usage)
            sys.exit(0)
        elif args[index] in ('-v', '--verbose'):
            options.verbose = True
            del args[index]
        elif args[index] in ('-o', '--output'):
            del args[index]
            if index == len(args):
                print('Missing output file or directory name', file=sys.stderr)
                sys.exit(1)
            options.output = os.path.abspath(args[index])
            del args[index]
        elif args[index] in ('-m', '--make-options'):
            del args[index]
            if index == len(args):
                print('Missing make options', file=sys.stderr)
                sys.exit(1)
            options.make_options = args[index]
            del args[index]
        elif args[index] == '--no-deps':
            options.dependencies = False
            del args[index]
        elif args[index] == '+dependencies':
            options.dependencies = False
            index += 1
        elif args[index] == '--bv_env':
            options.bv_env = True
            del args[index]
        elif args[index] == '--wrappers':
            options.wrappers = True
            del args[index]
        elif args[index] == '--packname':
            options.packname = True
            del args[index]
        elif args[index] == '--cmake':
            del args[index]
            if index == len(args):
                print('Missing cmake location', file=sys.stderr)
                sys.exit(1)
            options.cmake = args[index]
            del args[index]
        elif args[index] == '--tmp':
            del args[index]
            if index == len(args):
                print('Missing temporary directory name', file=sys.stderr)
                sys.exit(1)
            tempfile.tempdir = args[index]
            del args[index]
        elif args[index] == '--compressed-packdir':
            del args[index]
            if index == len(args):
                print('Missing compressed pack dir', file=sys.stderr)
                sys.exit(1)
            options.compressedpackdir = args[index]
            del args[index]
        elif args[index] == '--platform-target':
            del args[index]
            if index == len(args):
                print('Missing platform target', file=sys.stderr)
                sys.exit(1)
            options.platform_target = args[index]
            del args[index]
        elif args[index] == '--installer':
            options.installer = True
            del args[index]
        else:
            index += 1

    if len(args) < 1:
        print('No command given (use -h option to get help)', file=sys.stderr)
        sys.exit(1)
    command = commands.get(args[0])
    if command is None:
        print('Unknown command "%s" (use -h option to get help)'
              % args[0], file=sys.stderr)
        sys.exit(1)

    try:
        packages, dependencies = packages_selection(args[1:])
        command(options, packages, dependencies)
    except Warning as e:
        print(str(e), file=sys.stderr)
        sys.exit(1)
