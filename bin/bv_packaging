#!/usr/bin/env python
# -*- coding: utf-8 -*-

#  This software and supporting documentation are distributed by
#      Institut Federatif de Recherche 49
#      CEA/NeuroSpin, Batiment 145,
#      91191 Gif-sur-Yvette cedex
#      France
#
# This software is governed by the CeCILL-B license under
# French law and abiding by the rules of distribution of free software.
# You can  use, modify and/or redistribute the software under the 
# terms of the CeCILL-B license as circulated by CEA, CNRS
# and INRIA at the following URL "http://www.cecill.info". 
#
# As a counterpart to the access to the source code and  rights to copy,
# modify and redistribute granted by the license, users are provided only
# with a limited warranty  and the software's author,  the holder of the
# economic rights,  and the successive licensors  have only  limited
# liability.
#
# In this respect, the user's attention is drawn to the risks associated
# with loading,  using,  modifying and/or developing or reproducing the
# software by the user in light of its specific status of free software,
# that may mean  that it is complicated to manipulate,  and  that  also
# therefore means  that it is reserved for developers  and  experienced
# professionals having in-depth computer knowledge. Users are therefore
# encouraged to load and test the software's suitability as regards their
# requirements in conditions enabling the security of their systems and/or 
# data to be ensured and,  more generally, to use and operate it in the 
# same conditions as regards security.
#
# The fact that you are presently reading this means that you have had
# knowledge of the CeCILL-B license and that you accept its terms.

import sys, os, re, fnmatch, subprocess, tempfile, shutil
from stat import S_IRUSR, S_IXUSR, S_IRGRP, S_IXGRP, S_IROTH, S_IXOTH

if os.path.exists( sys.argv[0] ):
  this_script = sys.argv[0]
else:
  this_script = None
  for p in os.environ.get( 'PATH', '' ).split( os.pathsep ) + [ os.curdir ]:
    s = os.path.join( p, sys.argv[0] )
    if os.path.exists( s ):
      this_script = s
      break
if this_script:
  this_script = os.path.normpath( os.path.abspath( this_script ) )
  brainvisacmake_directory = os.path.dirname( os.path.dirname( this_script ) )
  python_modules = os.path.join( brainvisacmake_directory, 'python' )
  if os.path.isdir( python_modules ):
    sys.path.insert( 0, python_modules )


from brainvisa.compilation_info import packages_info, packages_dependencies, build_directory, build_system, build_processor

def system_call( options, command, cwd=None, env=None, return_output=False ):
  if options.verbose and not return_output:
    print
    print '->',' '.join( ( repr(i) for i in command ) )
    print
    stdout = None
    stderr = None
  else:
    stdout = subprocess.PIPE
    stderr = subprocess.STDOUT
  popen = subprocess.Popen( command,
                            stdout=stdout, stderr=stderr, cwd=cwd, env=env  )
  result = popen.communicate()[ 0 ]
  if popen.returncode:
    raise subprocess.CalledProcessError( popen.returncode, ' '.join( ( repr(i) for i in command ) ) )
  return result


def recursive_listdir( directory ):
  for i in os.listdir( directory ):
    item = os.path.join( directory, i )
    yield item
    if os.path.isdir( item ):
      for j in recursive_listdir( item ):
       yield j


def packages_selection( rules ):
  if not rules:
    rules = [ '+type=run', '-project=thirdparty' ]
  packages = set()
  for rule in rules:
    if not rule: continue
    if rule[ 0 ] in ( '+', '-' ):
      attributes={}
      for attribute_selection in rule[1:].split( ',' ):
        if not attribute_selection: continue
        try:
          attribute, pattern = attribute_selection.split( '=', 1 )
        except ValueError:
          attribute = 'name'
          pattern = attribute_selection
        attributes[ attribute ] = re.compile( fnmatch.translate( pattern ) )
      for package_info in packages_info.itervalues():
        selected = True
        for attribute, pattern in attributes.iteritems():
          value = package_info.get( attribute )
          if value is None:
            raise SyntaxWarning( 'Unknown attribute %s in rule %s' % ( repr( attribute ), repr( rule ) ) )
          if not pattern.match( value ):
            selected = False
            break
        if selected:
          if rule[ 0 ] == '+':
            packages.add( package_info[ 'name' ] )
          else:
            packages.discard( package_info[ 'name' ] )
    else:
      raise SyntaxWarning( 'A package selection rule must start with + or -: %s' % repr( rule ) )
    
    dependencies = set()
    todo = set( packages )
    while todo:
      package = todo.pop()
      for type, name, version, binary_independent in packages_dependencies.get( package, () ):
        if name not in packages and name not in dependencies:
          dependencies.add( name )
          todo.add( name )
  return ( packages, dependencies )


def list_selected_packages( options, selected_packages, dependencies ):
  if options.output is None:
    out = sys.stdout
  else:
    out = open( options.output, 'w' )
  if options.dependencies and dependencies:
    print >> out, 'Selected packages:'
    indent = '  '
  else:
    indent = ''
  print >> out, indent + ('\n'+indent).join( selected_packages )
  if options.dependencies and dependencies:
    print >> out, '\nDependencies packages:'
    print >> out, '  ' + '\n  '.join( dependencies )


def create_graphviz_dependencies( options, selected_packages, dependencies ):
  if options.output is None:
    out = sys.stdout
  else:
    out = open( options.output, 'w' )
  nodes = {}
  print >> out, 'digraph packages_dependencies {'
  done = set()
  todo = list( selected_packages )
  while todo:
    source_package = todo.pop( 0 )
    if source_package in done:
      continue
    done.add( source_package )
    source_package = packages_info[ source_package ]
    source_node = nodes.get( source_package[ 'name' ] )
    if source_node is None:
      source_node = str( len( nodes ) )
      nodes[ source_package[ 'name' ] ] = source_node
      if source_package[ 'project' ] == 'thirdparty':
        print >> out, '  %s [ label="%s", color=orange ]' % ( source_node, source_package[ 'name' ] )
      else:
        print >> out, '  %s [ label="%s" ]' % ( source_node, source_package[ 'name' ] )
    for dependency_type, dest_package, version_ranges, binary_independent  in packages_dependencies.get( source_package[ 'name' ], () ):
      if not options.dependencies and dest_package not in selected_packages:
        continue
      todo.append( dest_package )
      dest_package = packages_info[ dest_package ]
      dest_node = nodes.get( dest_package[ 'name' ] )
      if dest_node is None:
        dest_node = str( len( nodes ) )
        nodes[ dest_package[ 'name' ] ] = dest_node
        if dest_package[ 'project' ] == 'thirdparty':
          print >> out, '  %s [ label="%s", color=orange ]' % ( dest_node, dest_package[ 'name' ] )
        else:
          print >> out, '  %s [ label="%s" ]' % ( dest_node, dest_package[ 'name' ] )
      if dependency_type == 'DEPENDS':
        color='black'
      elif dependency_type == 'RECOMMENDS':
        color='green'
      else:
        color='blue'
      print >> out, '  %s -> %s [ color=%s ]' % ( source_node, dest_node, color )
  print >> out, '}'


def create_directory_package( options, selected_packages, dependencies, list_installed_paths=False ):
  if not options.output:
    raise UserWarning( 'Ouput directory must be given for this command' )
  install_directory = options.output
  if not os.path.exists( install_directory ):
    os.makedirs( install_directory )
  else:
    if list_installed_paths and os.listdir( install_directory ):
      raise UserWarning( 'This command cannot be done on an existing and non empty directory: %s' % repr( install_directory ) )
  installed_paths = {}
  current_dir=os.getcwd()
  os.chdir(build_directory)
  for package in ( selected_packages.union( dependencies ) if options.dependencies else selected_packages ):
    print 'Installing', package
    command = [ 'make', 'BRAINVISA_INSTALL_PREFIX=' + install_directory, 'install-' + packages_info[ package ]['component'] ]
    system_call( options, command )
    if list_installed_paths:
      # List files installed by package
      for i in ( j for j in recursive_listdir( install_directory ) if j not in installed_paths):
        installed_paths[ i ] = package
  os.chdir(current_dir)
  if options.bv_env:
    bindir = os.path.join( install_directory, 'bin' )
    if not os.path.exists( bindir ):
      os.mkdir( bindir )
    env_commands = ( 'bv_env', 'bv_env.sh', 'bv_unenv', 'bv_unenv.sh' )
    for command in env_commands:
      source = os.path.join( brainvisacmake_directory, 'bin', command )
      dest = os.path.join( bindir, command )
      open( dest, 'w' ).write( open( source ).read() )
      os.chmod( dest, os.stat( source ).st_mode )
    realbindir = os.path.join( bindir, 'real-bin' )
    if not os.path.exists( realbindir ):
      os.mkdir( realbindir )
    for command in os.listdir( bindir ):
      if command in env_commands:
        continue
      source = os.path.join( bindir, command )
      if os.path.isfile( source ) and not os.path.islink( source ):
        dest = os.path.join( realbindir, command )
        if os.path.exists( dest ):
          os.remove( dest )
        os.rename( source, dest )
        out = open( source, 'w' )
        out.write( '''#!/bin/sh
command=`basename $0`
directory="$0"
[ -L "$directory" ] && $directory="`dirname "$directory"`/`readlink "$directory"`"
directory="`dirname $directory`"
directory="`cd $directory;pwd`"
if [ -x "$directory/bv_env" ]; then
  exec "$directory/bv_env" "$directory/real-bin/$command" "$@"
else
  exec "$directory/real-bin/$command" "$@"
fi
''' )
        out.close()
        os.chmod( source, os.stat( dest ).st_mode )
        
  axon = os.path.join( install_directory, 'bin', 'brainvisa' )
  if os.path.exists( axon ):
    print 'Generating Axon processes documentation'
    env = os.environ.copy()
    env[ 'BRAINVISA_SHARE' ] = os.path.join( install_directory, 'share' )
    for variable, value in ( 
      ( 'PATH', os.path.join( install_directory, 'bin' ) ),
      ( 'PYTHONPATH', os.path.join( install_directory, 'python' ) ),
      ( 'LD_LIBRARY_PATH', os.path.join( install_directory, 'lib' ) ) ):
      path = env.get( variable )
      if path:
        env[ variable ] = value + os.pathsep + path
      else:
        env[ variable ] = path
    system_call( options, [ 'sh', axon, '-b', '--ignoreValidation', '--updateDocumentation' ], env=env )
    if list_installed_paths:
      print 'List generated files for Axon processes documentation'
      for i in ( j for j in recursive_listdir( install_directory ) if j not in installed_paths):
        installed_paths[ i ] = 'axon'
  if list_installed_paths:
    result = {}
    for path, package in  (( i[len(install_directory)+1:], j ) for i,j in installed_paths.iteritems() ):
      result.setdefault( package, [] ).append( path )
  else:
    result = None
  return result


def create_compressed_package( options, selected_packages, dependencies ):
  if not options.output:
    raise UserWarning( 'Ouput file name must be given for this command' )
  install_directory = tempfile.mkdtemp()
  try:
    output = options.output
    options.output = install_directory
    create_directory_package( options, selected_packages, dependencies )
    options.output = output
    print 'Compressing %s in %s' % (repr(install_directory), repr(output) )
    system_call( options, [ 'tar', 'jcf', output ] + os.listdir( install_directory ), cwd=install_directory )
  finally:
    print 'Removing %s' % repr(install_directory)
    shutil.rmtree( install_directory )


def validDebianPackageName( package ):
  # Debian package names only accepts alphanumeric or +- characters
  return package.replace( '_', '-' )

def create_debian_packages( options, selected_packages, dependencies ):
  if not options.output:
    output = os.getcwd()
  else:
    output = options.output
  if not os.path.exists( output ):
    os.makedirs( output )
  # Looking for architecture using apt-config if possible
  architecture = re.search( r'APT::Architecture *\"([^\"]*)\";?',
    subprocess.Popen( ( 'apt-config', 'dump' ), stdout=subprocess.PIPE, stderr=subprocess.STDOUT ).communicate()[0] )
  if architecture:
    architecture = architecture.group(1)
  else:
    architecture = build_processor
  
  # Create temporary install directory
  install_directory = tempfile.mkdtemp()
  try:
    options.output = install_directory
    installed_paths = create_directory_package( options, selected_packages, dependencies, list_installed_paths=True )
    options.output = output
    debs_directory = os.path.join( install_directory, 'deb_packages' )
    os.mkdir( debs_directory )
    for package, paths in installed_paths.iteritems():
      package_info = packages_info[ package ]
      debian_name = validDebianPackageName( package )
      package_info[ 'debian_name' ] = debian_name
      deb_file = os.path.join( options.output, debian_name + '-' + package_info[ 'version' ] + '-' + build_system + '-' + architecture + '.deb' )
      print 'Creating package', deb_file
      deb_directory = os.path.join( debs_directory, package )
      os.mkdir( deb_directory )
      
      # Create Debian control file
      os.mkdir( os.path.join( deb_directory, 'DEBIAN' ) )
      control = open( os.path.join( deb_directory, 'DEBIAN', 'control' ), 'w' )
      print >> control, ('''Package: %(debian_name)s
Version: %(version)s
Maintainer: %(maintainer)s
Architecture: ''' + architecture + '''
Description: %(type)s package for BrainVISA component %(name)s.
Priority: optional
Section: multiverse/science''') % package_info
      dependencies = {}
      for dependency_type, dest_package, version_ranges, binary_independent  in packages_dependencies.get( package, () ):
        for version_range in version_ranges.split( ';' ):
          dependencies.setdefault( dependency_type, [] ).append( validDebianPackageName( dest_package ) + ( ' ( ' + version_range + ' )' if version_ranges else '' ) )
      for dependency_type in ( 'DEPENDS', 'RECOMMENDS', 'SUGGESTS', 'ENHANCES' ):
        deps = dependencies.get( dependency_type )
        if deps:
          print >> control, dependency_type.capitalize() + ':', ', '.join( deps )
      deps = dependencies.get( 'RECOMMENDS' )
      if deps:
        print >> control, 'Depends:', ', '.join( deps )
      control.close()

      # Move files installed for this package in deb_directory
      for path in paths:
        source = os.path.join( install_directory, path )
        if os.path.isfile( source ):
          p, f = os.path.split( path )
          dest_directory = os.path.join( deb_directory, 'usr', p )
          if not os.path.exists( dest_directory ):
            os.makedirs( dest_directory )
          os.rename( source, os.path.join( dest_directory, f ) )
      
      # Creating *.deb file
      try:
        system_call( options, ( 'dpkg', '--build', deb_directory, deb_file ) )
      except subprocess.CalledProcessError:
        print >> sys.stderr, '\nDebian control file for %s' % package
        sys.stderr.write( open( control.name ).read() )
        raise
  finally:
    print 'Removing %s' % repr(install_directory)
    shutil.rmtree( install_directory )

commands = {
  'list': list_selected_packages,
  'dot': create_graphviz_dependencies,
  'dir': create_directory_package,
  'pack': create_compressed_package,
  'deb': create_debian_packages
}

if __name__ == '__main__':
  # Command line options cannot be parsed with optparse.OptionParser because
  # non-option values starting with '-' are not supported. So let's parse
  # options in the old way.
  class Empty:
    pass
  options = Empty()
  options.help = False
  options.output = None
  options.dependencies = True
  options.bv_env = False
  options.cmake = 'cmake'
  options.verbose = False
  
  usage = '''bv_packaging [options] <package_type> [ <selection_rule> ... ]

  This program is for the creation of packages and dependency graph for build directories.

  Package types:
    list: Only list selected packages
    dot: Create a Graphviz dependency graph for selected packages
    dir: Create a single directory containing all selected packages
    pack: Like "dir" but compress the result in a *.tar.bz2 archive
    deb: Create a debian package for each selected packages

  Selection rule:
    +<selection_pattern>: Adds all packages corresponding to the selection pattern
    -<selection_pattern>: Remove all packages corresponding to the selection pattern

  Selection pattern:
    <property>=<pattern>[,<property>=<pattern>...]: matc all packages where every selected property match the corresponding pattern
    <pattern>: equivalent to name=<pattern>

  Packages properties:
    name: Name of the package
    type: Type of the package
    version: Package version
    project: Name of the project containing the package.
    maintainer: Name of the maintainer of the package

  Package types:
    run: Runtime package
    dev: Development package
    doc: Documentation package
    thirdparty: Package corresponding to a thirdparty project not compiled in the build directory

  Default selection rule:
    +type=run: select all 

  Examples:
    Create a dependency graph for runtime packages
      bv_packaging -o /tmp/dependency-run.dot dot
    
    Create a dependency graph for development packages
      bv_packaging -o /tmp/dependency-dev.dot dot +type=dev
    
    Create debian packages for all runtime packages in soma project
      bv_packaging deb +project=soma,type=run
      
    Create debian packages for all runtime packages except brainvisa-system:
      bv_packaging deb +type=run -name=brainvisa-system
    
    List all packages whose name start with "a" excludind development packages
    without their dependent packages:
      bv_packaging --no-deps list '+a*'

Options:
  -h, --help            Show this help message and exit
  -v, --verbose         Show verbose information
  -o OUTPUT, --output=OUTPUT
                        File or directory where output will be stored.
  --no-deps             Do not include dependencies packages.
  --bv_env              Replace commands located in bib directory by a script that calls
                        the command through bv_env.
  --tmp DIRECTORY       Location of temporary directory (default is %(tmp)s).
  --cmake CMAKE_EXE     Location of cmake executable (default = %(cmake)s).
''' % { 'tmp': repr( tempfile.gettempdir() ),
        'cmake': repr( options.cmake ) }

  args = sys.argv[ 1: ]
  index = 0
  while index < len( args ):
    if args[ index ] in ( '-h', '--help' ):
      options.help = True
      print usage
      sys.exit( 0 )
    elif args[ index ] in ( '-v', '--verbose' ):
      options.verbose = True
      del args[ index ]
    elif args[ index ] in ( '-o', '--output' ):
      del args[ index ]
      if index == len( args ):
        print >> sys.stderr, 'Missing output file or directory name'
        sys.exit( 1 )
      options.output = args[ index ]
      del args[ index ]
    elif args[ index ] == '--no-deps':
      options.dependencies = False
      del args[ index ]
    elif args[ index ] == '--bv_env':
      options.bv_env = True
      del args[ index ]
    elif args[ index ] == '--cmake':
      del args[ index ]
      if index == len( args ):
        print >> sys.stderr, 'Missing cmake location'
        sys.exit( 1 )
      options.cmake = args[ index ]
      del args[ index ]
    elif args[ index ] == '--tmp':
      del args[ index ]
      if index == len( args ):
        print >> sys.stderr, 'Missing temporary directory name'
        sys.exit( 1 )
      tempfile.tempdir = args[ index ]
      del args[ index ]
    else:
      index += 1
  
  if len( args ) < 1:
    print >> sys.stderr, 'No command given (use -h option to get help)'
    sys.exit( 1 )
  command = commands.get( args[ 0 ] )
  if command is None:
    print >> sys.stderr, 'Unknown command "%s" (use -h option to get help)' % args[0]
    sys.exit( 1 )
  
  try:
    packages, dependencies = packages_selection( args[ 1: ] )
    command( options, packages, dependencies )
  except Warning, e:
    print >> sys.stderr, str( e )
    sys.exit( 1 )
  