get_filename_component( soma-infra_MODULE_DIR "${CMAKE_CURRENT_LIST_FILE}" PATH )
set( soma-infra_MODULE_DIR "${soma-infra_MODULE_DIR}/modules" )
set( CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} "${soma-infra_MODULE_DIR}" )

# OPTION( SOMA_BUILD_FROM_BINARY_DIR "Try to locate and use build directories for soma projects" )

# Requires CPack for its argument parsing macro
include( CPack )

macro( SOMA_PROJECT )
  include( "${CMAKE_CURRENT_SOURCE_DIR}/project_info.cmake" )
  project( ${CPACK_PACKAGE_NAME} )
  
  set( ${PROJECT_NAME}_VERSION_MAJOR ${CPACK_PACKAGE_VERSION_MAJOR} )
  set( ${PROJECT_NAME}_VERSION_MINOR ${CPACK_PACKAGE_VERSION_MINOR} )
  set( ${PROJECT_NAME}_VERSION_PATCH ${CPACK_PACKAGE_VERSION_PATCH} )
  set( ${PROJECT_NAME}_VERSION ${${PROJECT_NAME}_VERSION_MAJOR}.${${PROJECT_NAME}_VERSION_MINOR}.${${PROJECT_NAME}_VERSION_PATCH} )
  set( ${PROJECT_NAME}_VERSION_MAJOR ${CPACK_PACKAGE_VERSION_MAJOR} PARENT_SCOPE )
  set( ${PROJECT_NAME}_VERSION_MINOR ${CPACK_PACKAGE_VERSION_MINOR} PARENT_SCOPE )
  set( ${PROJECT_NAME}_VERSION_PATCH ${CPACK_PACKAGE_VERSION_PATCH} PARENT_SCOPE )
  set( ${PROJECT_NAME}_VERSION ${${PROJECT_NAME}_VERSION_MAJOR}.${${PROJECT_NAME}_VERSION_MINOR}.${${PROJECT_NAME}_VERSION_PATCH} PARENT_SCOPE )
  
  include( CPack )
  
  set( ${PROJECT_NAME}_TARGET_COUNT 0 CACHE INTERNAL "Used to generate new targets" )
  SOMA_CREATE_MAIN_COMPONENTS()
  
  set( ${PROJECT_NAME}_IS_COMPILED ON PARENT_SCOPE )
  set( CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin )
  set( CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib )
endmacro( SOMA_PROJECT )


# TODO: delete this macro
macro( SOMA_CREATE_MAIN_COMPONENTS )
  if( NOT SOMA_MAIN_COMPONENTS_CREATED )
    set( SOMA_MAIN_COMPONENTS_CREATED true )
    SOMA_ADD_COMPONENT_GROUP( runtime
                              DISPLAY_NAME "Runtime"
                              DESCRIPTION "All elements necessary to use ${PROJECT_NAME} at runtime without developpement files such as C++ headers." )
    SOMA_ADD_COMPONENT_GROUP( devel
                              DISPLAY_NAME "Developpement"
                              DESCRIPTION "All elements necessary to compile libraries and programs that uses ${PROJECT_NAME} (such as C++ headers)." )
    SOMA_ADD_COMPONENT_GROUP( doc
                              DISPLAY_NAME "Documentation"
                              DESCRIPTION "All documentations: doxygen, epydoc, etc." )
    SOMA_ADD_COMPONENT_GROUP( doxygen-doc
                              PARENT_GROUP doc
                              DISPLAY_NAME "Doxygen documentation"
                              DESCRIPTION "Documentation generated by Doxygen." )
    SOMA_ADD_COMPONENT_GROUP( epydoc-doc
                              PARENT_GROUP doc
                              DISPLAY_NAME "Epydoc documentation"
                              DESCRIPTION "Documentation generated by Epydoc." )
    SOMA_ADD_COMPONENT_GROUP( html-doc
                              PARENT_GROUP doc
                              DISPLAY_NAME "HTML documentation"
                              DESCRIPTION "Documentation written in HTML." )
    SOMA_ADD_COMPONENT_GROUP( share
                              DISPLAY_NAME "Shared files"
                              DESCRIPTION "Files shared by several projects." )
    SOMA_ADD_COMPONENT( system-runtime
                        GROUP devel
                        DESCRIPTION "Developpement files for ${PROJECT_NAME}"
                        DEPENDS ${PROJECT_NAME} )
    add_dependencies( install-runtime install-share )
    add_dependencies( install-devel install-runtime )
    add_custom_target( doc )
    add_dependencies( install-doc doc )
    add_custom_target( install-nodoc )
    add_dependencies( install-nodoc install-runtime install-devel install-share )

  endif( NOT SOMA_MAIN_COMPONENTS_CREATED )

  SOMA_ADD_COMPONENT( ${PROJECT_NAME}
                      GROUP runtime
                      DESCRIPTION "runtime files for ${PROJECT_NAME}" )
  SOMA_ADD_COMPONENT( ${PROJECT_NAME}-devel 
                      GROUP devel
                      DESCRIPTION "Developpement files for ${PROJECT_NAME}"
                      DEPENDS ${PROJECT_NAME} )
  SOMA_ADD_COMPONENT( ${PROJECT_NAME}-share 
                      GROUP devel
                      DESCRIPTION "Shared files for ${PROJECT_NAME}"
                      DEPENDS ${PROJECT_NAME} )
  SOMA_ADD_COMPONENT( ${PROJECT_NAME}-doxygen
                      GROUP doxygen-doc
                      DESCRIPTION "Doxygen documentation of ${PROJECT_NAME}" )
  SOMA_ADD_COMPONENT( ${PROJECT_NAME}-epydoc
                      GROUP epydoc-doc
                      DESCRIPTION "Epydoc documentation of ${PROJECT_NAME}" )
  SOMA_ADD_COMPONENT( ${PROJECT_NAME}-html
                      GROUP html-doc
                      DESCRIPTION "HTML documentation of ${PROJECT_NAME}" )
  SOMA_ADD_COMPONENT( ${PROJECT_NAME}-doc
                      GROUP doc
                      DESCRIPTION "Documentation of ${PROJECT_NAME}" )
endmacro( SOMA_CREATE_MAIN_COMPONENTS )


function( SOMA_CREATE_PACKAGING_RULES )
  # Rules for packaging
  set( _packageSuffix "${CMAKE_SYSTEM_NAME}-${CMAKE_SYSTEM_PROCESSOR}" )
  set( _allPackages )
  foreach( _project ${SOMA_BUILD_PROJECTS} )
    set( _tmpDir "${SOMA_PACKAGING_TEMPORARY_DIRECTORY}/${_project}" )
    set( _packageName "${SOMA_PACKAGING_TEMPORARY_DIRECTORY}/${_project}-${${_project}_VERSION}-${_packageSuffix}.tar.bz2" )
    set( _packageNameDevel "${SOMA_PACKAGING_TEMPORARY_DIRECTORY}/${_project}-devel-${${_project}_VERSION}-${_packageSuffix}.tar.bz2" )
    add_custom_command( OUTPUT "${_packageName}"
      COMMENT "Packaging ${_packageName}"
      COMMAND ${CMAKE_COMMAND} -E remove_directory "${_tmpDir}"
      COMMAND ${CMAKE_COMMAND} -E make_directory "${_tmpDir}"
      COMMAND ${CMAKE_COMMAND} "-DCMAKE_INSTALL_PREFIX=${_tmpDir}" -DCMAKE_INSTALL_COMPONENT=${_project} -P "${CMAKE_BINARY_DIR}/cmake_install.cmake"
      COMMAND tar "--directory=${_tmpDir}" -jcf "${_packageName}" .
      COMMAND ${CMAKE_COMMAND} -E remove_directory "${_tmpDir}"
    )
    set( _allPackages ${_allPackages} "${_packageName}" )
  
    add_custom_command( OUTPUT "${_packageNameDevel}"
      COMMENT "Packaging ${_packageNameDevel}"
      COMMAND ${CMAKE_COMMAND} -E remove_directory "${_tmpDir}-devel"
      COMMAND ${CMAKE_COMMAND} -E make_directory "${_tmpDir}-devel"
      COMMAND ${CMAKE_COMMAND} "-DCMAKE_INSTALL_PREFIX=${_tmpDir}-devel" -DCMAKE_INSTALL_COMPONENT=${_project}-devel -P "${CMAKE_BINARY_DIR}/cmake_install.cmake"
      COMMAND tar "--directory=${_tmpDir}-devel" -jcf "${_packageNameDevel}" .
      COMMAND ${CMAKE_COMMAND} -E remove_directory "${_tmpDir}-devel"
    )
    set( _allPackages ${_allPackages} "${_packageNameDevel}" )
  
  endforeach( _project ${SOMA_ALL_PROJECTS} )
  
  set( _packageName "${SOMA_PACKAGING_TEMPORARY_DIRECTORY}/system-${_packageSuffix}.tar.bz2" )
  set( _tmpDir "${SOMA_PACKAGING_TEMPORARY_DIRECTORY}/system" )
  add_custom_command( OUTPUT "${_packageName}"
    COMMENT "Packaging ${_packageName}"
    COMMAND ${CMAKE_COMMAND} -E remove_directory "${_tmpDir}"
    COMMAND ${CMAKE_COMMAND} -E make_directory "${_tmpDir}"
    COMMAND ${CMAKE_COMMAND} "-DCMAKE_INSTALL_PREFIX=${_tmpDir}" -DCMAKE_INSTALL_COMPONENT=system-runtime -P "${CMAKE_BINARY_DIR}/cmake_install.cmake"
    COMMAND tar "--directory=${_tmpDir}" -jcf "${_packageName}" .
    COMMAND ${CMAKE_COMMAND} -E remove_directory "${_tmpDir}"
  )
  set( _allPackages ${_allPackages} "${_packageName}" )
  
  add_custom_target( packages
    COMMAND ${CMAKE_COMMAND} -E make_directory "${SOMA_PACKAGING_TEMPORARY_DIRECTORY}"
    DEPENDS ${_allPackages}
  )
endfunction( SOMA_CREATE_PACKAGING_RULES )



macro( SOMA_FIND_PACKAGE _package )
#   if( SOMA_BUILD_FROM_BINARY_DIR )
    get_filename_component( _binaryDir "${CMAKE_BINARY_DIR}" PATH )
    set( _binaryDirs "${_binaryDir}/${_package}" "${CMAKE_BINARY_DIR}/${_package}" )
    foreach( _binaryDir ${_binaryDirs} )
      if( EXISTS "${_binaryDir}/CMakeCache.txt" )
        set( CMAKE_PREFIX_PATH ${CMAKE_PREFIX_PATH} "${_binaryDir}" )
        break()
      endif( EXISTS "${_binaryDir}/CMakeCache.txt" )
    endforeach( _binaryDir ${_binaryDirs} )
#   endif( SOMA_BUILD_FROM_BINARY_DIR )
  find_package( "${_package}" ${ARGN} )
endmacro( SOMA_FIND_PACKAGE package )


# SOMA_SET_PROJECT_VERSION
#   Read the VERSION file in "${PROJECT_SOURCE_DIR} and parse it to set the
#   following variables:
#     ${PROJECT_NAME}_VERSION = full version string (i.e. VERSION file content)
#     ${PROJECT_NAME}_VERSION_MAJOR = major version number (i.e. first number)
#     ${PROJECT_NAME}_VERSION_MINOR = minor version number (i.e. second number)
#     ${PROJECT_NAME}_VERSION_PATCH = patch version number (if any)
#   The following variables are also set with the same values as above:
#     SOMA_CURRENT_PROJECT_VERSION
#     SOMA_CURRENT_PROJECT_VERSION_MAJOR
#     SOMA_CURRENT_PROJECT_VERSION_MINOR
#     SOMA_CURRENT_PROJECT_VERSION_PATCH
#
# Usage:
#   SOMA_SET_PROJECT_VERSION()
MACRO( SOMA_SET_PROJECT_VERSION )
  SET( _versionVar ${PROJECT_NAME}_VERSION )
  IF( NOT DEFINED ${_versionVar} )
    FILE( READ "${PROJECT_SOURCE_DIR}/VERSION" _version )
    STRING( REGEX REPLACE "([^\n]*)\n" "\\1" _version "${_version}")
    STRING( REGEX REPLACE "([^.]+)\\.([^.]+)(\\.(.*))?" "\\1" _version_major "${_version}")
    STRING( REGEX REPLACE "([^.]+)\\.([^.]+)(\\.(.*))?" "\\2" _version_minor "${_version}")
    STRING( REGEX REPLACE "([^.]+)\\.([^.]+)\\.?(.*)" "\\3" _version_patch "${_version}")

    SET( ${_versionVar} ${_version} )
    SET( ${_versionVar}_MAJOR ${_version_major} )
    SET( ${_versionVar}_MINOR ${_version_minor} )
    SET( ${_versionVar}_PATCH ${_version_patch} )

    SET( SOMA_CURRENT_PROJECT_VERSION  ${${_versionVar}} )
    SET( SOMA_CURRENT_PROJECT_VERSION_MAJOR ${${_versionVar}_MAJOR} )
    SET( SOMA_CURRENT_PROJECT_VERSION_MINOR ${${_versionVar}_MINOR} )
    SET( SOMA_CURRENT_PROJECT_VERSION_PATCH ${${_versionVar}_PATCH} )
  ENDIF( NOT DEFINED ${_versionVar} )
ENDMACRO( SOMA_SET_PROJECT_VERSION )


function( SOMA_GENERATE_TARGET_NAME _variableName )
  if( DEFINED ${PROJECT_NAME}_TARGET_COUNT )
    math( EXPR ${PROJECT_NAME}_TARGET_COUNT ${${PROJECT_NAME}_TARGET_COUNT}+1 )
    set( ${PROJECT_NAME}_TARGET_COUNT ${${PROJECT_NAME}_TARGET_COUNT} CACHE INTERNAL "Used to generate new targets" )
  else( DEFINED ${PROJECT_NAME}_TARGET_COUNT )
    set( ${PROJECT_NAME}_TARGET_COUNT 1 CACHE INTERNAL "Used to generate new targets" )
  endif( DEFINED ${PROJECT_NAME}_TARGET_COUNT )
  set( ${_variableName} ${PROJECT_NAME}_target_${${PROJECT_NAME}_TARGET_COUNT} PARENT_SCOPE )
endfunction( SOMA_GENERATE_TARGET_NAME )


# SOMA_GET_FILE_LIST_FROM_PRO
#   Retrieve one (or more) list of file names from an *.pro file. This macro
#   exists for backward compatibility with build-config.
#
# Usage:
#   SOMA_GET_FILE_LIST_FROM_PRO( <pro file name> <pro variable> <cmake variable> [<pro variable> <cmake variable>...] )
#
# Example:
#   SOMA_GET_FILE_LIST_FROM_PRO(  ${CMAKE_CURRENT_SOURCE_DIR}/libvip.pro "HEADERS" _h "SOURCES" _s )
#
MACRO( SOMA_GET_FILE_LIST_FROM_PRO _proFilename)
  file(READ "${_proFilename}" _var)
  # remove lines starting with '#'
  string(REGEX REPLACE "#[^\n]*\n" "" _var "${_var}")
  string(REGEX REPLACE "[ \t]*\\\\ *\n[ \t]*" " " _var "${_var}")
  
  SET( _args ${ARGN})
  LIST( LENGTH _args _i )
  WHILE( ${_i} GREATER 0 )
    LIST( GET _args 0 _proVariable )
    LIST( GET _args 1 _cmakeVariable )
    LIST( REMOVE_AT _args 0 1 )
    STRING( REGEX REPLACE "(.*\n)?${_proVariable}[ \t]*\\+?=[ \t]*([^\n]*)\n.*" "\\2" ${_cmakeVariable} "${_var}" )
    SEPARATE_ARGUMENTS( ${_cmakeVariable} )
#     MESSAGE( "${_proVariable} : ${${_cmakeVariable}}" )
    LIST( LENGTH _args _i )
  ENDWHILE( ${_i} GREATER 0 )
ENDMACRO( SOMA_GET_FILE_LIST_FROM_PRO )


# SOMA_COPY_AND_INSTALL_HEADERS
#
# Usage:
#   SOMA_COPY_AND_INSTALL_HEADERS( <headers list> <include directory> <install component> )
#
# Example:
#
MACRO( SOMA_COPY_AND_INSTALL_HEADERS _headersVariable _includeDir )
  FOREACH( _currentHeader ${${_headersVariable}} )
    CONFIGURE_FILE( ${CMAKE_CURRENT_SOURCE_DIR}/${_currentHeader}
                    ${CMAKE_BINARY_DIR}/include/${_includeDir}/${_currentHeader}
                    COPYONLY )
    GET_FILENAME_COMPONENT( _path "${_currentHeader}" PATH )
    SOMA_INSTALL( FILES ${_currentHeader}
                  DESTINATION include/${_includeDir}/${_path}
                  COMPONENT ${PROJECT_NAME}-devel )
  ENDFOREACH( _currentHeader ${${_headersVariable}} )
ENDMACRO( SOMA_COPY_AND_INSTALL_HEADERS _headersVariable _includeDir )


# SOMA_COPY_FILES
#
# Usage:
#  SOMA_COPY_FILES( <component> [ <source files> [SOURCE_DIRECTORY <directory>] DESTINATION <destination directory> ]... )
#
macro( SOMA_COPY_FILES _component )
  set( _targetDepends )
  set( _i 0 )
  set( _argn ${ARGN} )
  list( LENGTH _argn _lengthARGN )
  while( ${_i} LESS ${_lengthARGN} )
    # Read source file list
    set( _files )
    while( ${_i} LESS ${_lengthARGN} )
      list( GET _argn ${_i} _item )
      if( "${_item}" STREQUAL "SOURCE_DIRECTORY" OR "${_item}" STREQUAL "DESTINATION" )
        break()
      endif( "${_item}" STREQUAL "SOURCE_DIRECTORY" OR "${_item}" STREQUAL "DESTINATION" )
      set( _files ${_files} "${_item}" )
      math( EXPR _i "${_i} + 1" )
    endwhile( ${_i} LESS ${_lengthARGN} )

    # Read options
    set( _sourceDirectory )
    if( "${_item}" STREQUAL SOURCE_DIRECTORY )
      math( EXPR _i "${_i} + 1" )
      list( GET _argn ${_i} _sourceDirectory )
      math( EXPR _i "${_i} + 1" )
    endif( "${_item}" STREQUAL SOURCE_DIRECTORY )
    math( EXPR _i "${_i} + 1" )
    list( GET _argn ${_i} _destination )
    math( EXPR _i "${_i} + 1" )

#     message( "=== copy: from ${_sourceDirectory} to ${_destination} : ${_files}" )
    foreach( _file ${_files} )
      if( IS_ABSOLUTE "${_file}" )
        set( _absoluteFile "${_file}"  )
        set( _path )
        get_filename_component( _file "${_file}" NAME )
      elseif( _sourceDirectory )
        set( _absoluteFile "${_sourceDirectory}/${_file}"  )
        get_filename_component( _path "${_file}" PATH )
      else( IS_ABSOLUTE "${_file}" )
        set( _absoluteFile "${_file}"  )
        get_filename_component( _path "${_file}" PATH )
    endif( IS_ABSOLUTE "${_file}" )
      configure_file( "${_absoluteFile}"
                      "${CMAKE_BINARY_DIR}/${_destination}/${_file}"
                      COPYONLY )
      SOMA_INSTALL( FILES "${_absoluteFile}" 
                    DESTINATION "${_destination}/${_path}"
                    COMPONENT  ${_component} )
      set( _targetDepends ${_targetDepends} "${CMAKE_BINARY_DIR}/${_destination}/${_file}" )
    endforeach( _file ${_files} )
  endwhile( ${_i} LESS ${_lengthARGN} )
  SOMA_GENERATE_TARGET_NAME( _target )
  add_custom_target( ${_target} ALL
                     DEPENDS ${_targetDepends} )
endmacro( SOMA_COPY_FILES )


# SOMA_COPY_DIRECTORY
#  Recursively copy and install all files in <source directory> except files named
#  CMakeLists.txt or *~.
#
# Usage:
#  SOMA_COPY_DIRECTORY( <source directory> <destination directory> <component> )
#
macro( SOMA_COPY_DIRECTORY _directory _destination _component )
  file( GLOB_RECURSE _files RELATIVE "${_directory}" "${_directory}/*" )
  set( _selectedFiles )
  foreach( _i ${_files} )
    get_filename_component( _f ${_i} NAME )
    string( REGEX MATCH "(CMakeLists\\.txt)|(.*~)$"_match ${_f} )
    if( NOT _match )
      set( _selectedFiles ${_selectedFiles} ${_i} )
    endif( NOT _match )
  endforeach( _i ${_files} )
  SOMA_COPY_FILES( ${_component} ${_selectedFiles} SOURCE_DIRECTORY "${_directory}" DESTINATION "${_destination}" )
endmacro( SOMA_COPY_DIRECTORY _directory _destination _component )


# SOMA_COPY_PYTHON_DIRECTORY
#   Create targets to copy, byte compile and install all Python code
#   contained in a directory.
#
# Usage:
#   SOMA_COPY_PYTHON_DIRECTORY( <python directory> <component> 
#                               <destination directory> )
#     <python directory>: python directory to copy
#     <component>: name of the component passed to SOMA_INSTALL.
#     <destination directory>: directory where the wiles will be copied
#         (relative to build directory).
#   SOMA_COPY_PYTHON_DIRECTORY( <python directory> <component> )
#     <destination directory> is set to the right most directory name in
#         <python directory>
#
# Example:
#   SOMA_COPY_PYTHON_DIRECTORY(  ${CMAKE_CURRENT_SOURCE_DIR}/python brainvisa_python )
#
macro( SOMA_COPY_PYTHON_DIRECTORY _pythonDirectory _component )
  if( ${ARGC} GREATER 2 )
    set( _destDir "${ARGV2}" )
  else( ${ARGC} GREATER 2 )
    get_filename_component( _destDir "${_pythonDirectory}" NAME )
  endif( ${ARGC} GREATER 2 )

  # Make sure Python can be executed
  if( NOT DEFINED PYTHON_EXECUTABLE )
    find_package( PythonInterp REQUIRED )
  endif( NOT DEFINED PYTHON_EXECUTABLE )
  
  # Read source directory and separate Python sources (*.py) from other files
  set( _pythonSources )
  set( _nonPythonSources )
  file( GLOB_RECURSE _files RELATIVE "${_pythonDirectory}" "${_pythonDirectory}/*" )
  foreach( _i ${_files} )
    get_filename_component( _f ${_i} NAME )
    string( REGEX MATCH "(CMakeLists\\.txt)|(.*~)|(.*\\.pyo)|(.*\\.pyc)$" _match ${_f} )
    if( NOT _match )
      string( REGEX MATCH ".*\\.py$" _match ${_f} )
      if( _match )
        set( _pythonSources ${_pythonSources} ${_i} )
      else( _match )
        set( _nonPythonSources ${_nonPythonSources} ${_i} )
      endif( _match )
    endif( NOT _match )
  endforeach( _i ${_files} )

  # List containing all source files and also byte compiled files in the build directory
  set( _targetDepends )

  # Copy or symlink Python sources
  foreach(_file ${_pythonSources})
    # Copy the source file in build directory
    set( _fileBuild "${CMAKE_BINARY_DIR}/${_destDir}/${_file}" )
    if( UNIX OR APPLE )
      # Make a symlink instead of copying Python source allows to
      # execute code from the build tree and directly benefit from
      # modifications in the source tree (without typing make)
      get_filename_component( _path "${_fileBuild}" PATH )
      add_custom_command( OUTPUT "${_fileBuild}"
                          COMMAND ${CMAKE_COMMAND} -E make_directory "${_path}"
                          COMMAND ${CMAKE_COMMAND} -E create_symlink "${_pythonDirectory}/${_file}" "${_fileBuild}"
                          DEPENDS "${_pythonDirectory}/${_file}" )
    else( UNIX OR APPLE )
      configure_file( "${_pythonDirectory}/${_file}"
                      "${_fileBuild}"
                      COPYONLY )
    endif( UNIX OR APPLE )

    # Byte compile python code (creating *.pyc and *.pyo)
    add_custom_command( OUTPUT "${_fileBuild}c"
                        COMMAND ${PYTHON_EXECUTABLE} -c "import py_compile\\;py_compile.main\\(\\)" "${_fileBuild}"
                        DEPENDS "${_fileBuild}" )
    add_custom_command( OUTPUT "${_fileBuild}o"
                        COMMAND ${PYTHON_EXECUTABLE} -O -c "import py_compile\\;py_compile.main\\(\\)" "${_fileBuild}"
                        DEPENDS "${_fileBuild}" )
  
    # Install source file and byte compiled files
    get_filename_component( _path "${_file}" PATH )
    SOMA_INSTALL( FILES "${_pythonDirectory}/${_file}" "${_fileBuild}c" "${_fileBuild}o"
                  DESTINATION ${_destDir}/${_path}
                  COMPONENT ${_component} )
    set( _targetDepends ${_targetDepends} "${_fileBuild}" "${_fileBuild}c" "${_fileBuild}o" )
  endforeach(_file ${_pythonSources})

  # Copy other files
  foreach(_file ${_nonPythonSources})
    set( _fileBuild "${CMAKE_BINARY_DIR}/${_destDir}/${_file}" )
    configure_file( "${_pythonDirectory}/${_file}"
                    "${_fileBuild}"
                    COPYONLY )
    # Install source file and byte compiled files
    get_filename_component( _path "${_file}" PATH )
    SOMA_INSTALL( FILES "${_pythonDirectory}/${_file}"
                  DESTINATION ${_destDir}/${_path}
                  COMPONENT ${_component} )
    set( _targetDepends ${_targetDepends} "${_fileBuild}" )
  endforeach(_file ${_nonPythonSources})


  # Make a target that depends on all files that must be copied or generated
  # Is there a better way to force files creation ?
  SOMA_GENERATE_TARGET_NAME( _target )
  add_custom_target( ${_target} ALL
                     DEPENDS ${_targetDepends} )
endmacro( SOMA_COPY_PYTHON_DIRECTORY _pythonDirectory _component )


# SOMA_GET_SPACED_QUOTED_LIST
#   Transform a list into a string containing space separated items. Each item
#   is surounded by double quotes.
#
# Usage:
#  SOMA_GET_SPACED_QUOTED_LIST( <list variable> <output variable> )
#
# Example:
#   SET( _list a b "c d" )
#   SOMA_GET_SPACED_QUOTED_LIST( _list _quotedList )
#   # equivalent to SET( _quotedList "\"a\" \"b\" \"c d\"" )
MACRO( SOMA_GET_SPACED_QUOTED_LIST _listVariable _outputVariable )
  SET( _list ${${_listVariable}} )
  SET( ${_outputVariable} )
  LIST( LENGTH _list _length )
  IF( _length GREATER 0 )
    LIST( GET _list 0 _item )
    LIST( REMOVE_AT _list 0 )
    STRING( REPLACE "\"" "\\\"" _item ${_item}  )
    SET( ${_outputVariable} "\"${_item}\"" )
    FOREACH( _item ${_list} )
      STRING( REPLACE "\"" "\\\"" _item ${_item}  )
      SET( ${_outputVariable} "${${_outputVariable}} \"${_item}\"" )
    ENDFOREACH( _item ${list} )
  ENDIF( _length GREATER 0 )
ENDMACRO( SOMA_GET_SPACED_QUOTED_LIST _listVariable _outputVariable )


# SOMA_GENERATE_DOXYGEN_DOC
#    Add rules to generate doxygen documentation with "make doc".
#
# Usage:
#   SOMA_GENERATE_DOXYGEN_DOC( <input_variable> [<file to copy> ...] )
#   <input_variable>: variable containing a string or a list of input sources. 
#                     Its content will be copied in the INPUT field of the 
#                     Doxygen configuration file.
#  <file to copy>: file (relative to ${CMAKE_CURRENT_SOURCE_DIR}) to copy in
#                  the build tree. Files are copied in ${DOXYGEN_BINARY_DIR}
#                  if defined, otherwise they are copied in 
#                  ${PROJECT_BINARY_DIR}/doxygen. The doxygen configuration
#                  file is generated in the same directory.
#
#   Before calling this macro, it is possible to specify values that are going
#   to be written in doxygen configuration file by setting variable names
#   DOXYFILE_<doxyfile variable name>. For instance, in order to set project
#   name in Doxygen, one should use 
#   SET( DOXYFILE_PROJECT_NAME, "My wonderful project" ).
#
# Example:
#     FIND_PACKAGE( Doxygen )
#     IF ( DOXYGEN_FOUND )
#       INCLUDE( SomaMacros )
#       SET( DOXYFILE_HTML_HEADER "\"${DOXYGEN_BINARY_DIR}/head_vip.html\"" )
#       SET( DOXYFILE_OPTIMIZE_OUTPUT_FOR_C YES )
#       SET( DOXYFILE_BUILTIN_STL_SUPPORT NO )
#       FILE( READ "${DOXYGEN_BINARY_DIR}/doxygenInput" _doxygenInput )
#       SOMA_GENERATE_DOXYGEN_DOC( _doxygenInput head_vip.html vip.gif )
#     ENDIF ( DOXYGEN_FOUND )
MACRO( SOMA_GENERATE_DOXYGEN_DOC _inputVariable )
  IF( DOXYGEN_FOUND )
    IF( DEFINED DOXYGEN_BINARY_DIR )
      SET( _doxygenBinaryDir "${DOXYGEN_BINARY_DIR}" )
    ELSE( DEFINED DOXYGEN_BINARY_DIR )
      SET( _doxygenBinaryDir "${PROJECT_BINARY_DIR}/doxygen" )
    ENDIF( DEFINED DOXYGEN_BINARY_DIR )
  
    # If files in _inputVariable are relative, make them absolute
    list( GET ${_inputVariable} 0 _item )
    if( NOT EXISTS "${_item}" )
      set( _newList )
      foreach( _item ${${_inputVariable}} )
        set( _newList ${_newList} "${CMAKE_CURRENT_SOURCE_DIR}/${item}" )
      endforeach( _item ${${_inputVariable}} )
      SOMA_GET_SPACED_QUOTED_LIST( _newList _input )
    else( NOT EXISTS "${_item}" )
      SOMA_GET_SPACED_QUOTED_LIST( ${_inputVariable} _input )
    endif( NOT EXISTS "${_item}" )

    SET( DOXYFILE_INPUT "${_input}" )
    INCLUDE( "${soma-infra_DIR}/DoxyfileDefaultValues.cmake" )

    SET( _generatedFiles )
    FOREACH( _file ${ARGN} )
      CONFIGURE_FILE( "${CMAKE_CURRENT_SOURCE_DIR}/${_file}" 
                      "${_doxygenBinaryDir}/${_file}"
                      COPYONLY )
      CONFIGURE_FILE( "${CMAKE_CURRENT_SOURCE_DIR}/${_file}" 
                      "${DOXYFILE_HTML_OUTPUT}/${_file}"
                      COPYONLY )
      SET( _generatedFiles ${_generatedFiles} "${DOXYFILE_HTML_OUTPUT}/${_file}" "${_doxygenBinaryDir}/${_file}" )
    ENDFOREACH( _file ${ARGN} )
  
    CONFIGURE_FILE( "${soma-infra_DIR}/Doxyfile.in" "${_doxygenBinaryDir}/Doxyfile" @ONLY )
    SOMA_GENERATE_TARGET_NAME( _target )
    ADD_CUSTOM_TARGET( ${_target} 
                      DEPENDS "${_doxygenBinaryDir}/Doxyfile" ${_generatedFiles}
                      COMMAND ${CMAKE_COMMAND} -E make_directory "${DOXYFILE_OUTPUT_DIRECTORY}"
                      COMMAND "${DOXYGEN_EXECUTABLE}" "${_doxygenBinaryDir}/Doxyfile" )
    # Make sure doc target exists, I do not know if it is clean
    ADD_DEPENDENCIES( doc ${_target} )
    # Install HTML documentation
    if( IS_ABSOLUTE "${DOXYFILE_HTML_OUTPUT}" )
      set( _directory "${DOXYFILE_HTML_OUTPUT}" )
    else( IS_ABSOLUTE "${DOXYFILE_HTML_OUTPUT}" )
      set( _directory "${DOXYFILE_OUTPUT_DIRECTORY}/${DOXYFILE_HTML_OUTPUT}" )
    endif( IS_ABSOLUTE "${DOXYFILE_HTML_OUTPUT}" )
    SOMA_INSTALL( DIRECTORY "${_directory}"
                  DESTINATION "share/doc/${PROJECT_NAME}-${DOXYFILE_PROJECT_VERSION}/doxygen"
                  COMPONENT ${PROJECT_NAME}-doc )
  ENDIF( DOXYGEN_FOUND )
ENDMACRO( SOMA_GENERATE_DOXYGEN_DOC )


# SOMA_GENERATE_EPYDOC_DOC
#    Add rules to generate epydoc documentation with "make doc".
#
macro( SOMA_GENERATE_EPYDOC_DOC _sourceDirectory _outputDirectory )
  if( Epydoc_FOUND )
    file( GLOB_RECURSE _pythonFiles "${_sourceDirectory}/*.py" )
    if( DOT_EXECUTABLE )
      set( _dotParameters --dotpath "${DOT_EXECUTABLE}" --graph classtree )
    endif( DOT_EXECUTABLE )
    SOMA_GENERATE_TARGET_NAME( _target )
    add_custom_target( ${_target}
                      DEPENDS ${_pythonFiles}
                      COMMAND ${CMAKE_COMMAND} -E make_directory "${CMAKE_BINARY_DIR}/${_outputDirectory}"
                      COMMAND "${EPYDOC_EXECUTABLE}" 
                        --html
                        --name "${PROJECT_NAME} ${SOMA_CURRENT_PROJECT_VERSION}"
                        -o "${CMAKE_BINARY_DIR}/${_outputDirectory}"
                        --inheritance grouped
                        ${_dotParameters}
                        ${_pythonFiles} )
    add_dependencies( doc ${_target} )
    # Install HTML documentation
    SOMA_INSTALL( DIRECTORY "${CMAKE_BINARY_DIR}/${_outputDirectory}"
                  DESTINATION "${_outputDirectory}"
                  COMPONENT ${PACKAGE_NAME}-doc )
  endif( Epydoc_FOUND )
endmacro( SOMA_GENERATE_EPYDOC_DOC )



#
#
MACRO( SOMA_ADD_COMPONENT_GROUP _group )
  set( _readVariable )
  set( _parentGroup )
  foreach( _i ${ARGN} )
    if( _readVariable )
      set( ${_readVariable} "${_i}" )
#       set( _readVariable )
      break()
    else( _readVariable )
      if( "${_i}" STREQUAL PARENT_GROUP )
        set( _readVariable _parentGroup )
      endif( "${_i}" STREQUAL PARENT_GROUP )
    endif( _readVariable )
  endforeach( _i ${ARGN} )

#   message( "Create group ${_group} with parent \"${_parentGroup}\"" )
  cpack_add_component_group( ${_group} ${ARGN} )
  add_custom_target( install-${_group} )
  if( _parentGroup )
    add_dependencies( install-${_parentGroup} install-${_group} )
  endif( _parentGroup )
ENDMACRO( SOMA_ADD_COMPONENT_GROUP _group )


#
#
MACRO( SOMA_ADD_COMPONENT _component )
  set( _readVariable )
  set( _group )
  foreach( _i ${ARGN} )
    if( _readVariable )
      set( ${_readVariable} "${_i}" )
#       set( _readVariable )
      break()
    else( _readVariable )
      if( "${_i}" STREQUAL GROUP )
        set( _readVariable _group )
      endif( "${_i}" STREQUAL GROUP )
    endif( _readVariable )
  endforeach( _i ${ARGN} )

#   message( "Create component ${_component} in group ${_group}" )
  cpack_add_component( ${_component}
                       ${ARGN} )
  add_custom_target( install-${_component}
                     COMMAND ${CMAKE_COMMAND} -DCOMPONENT=${_component} -P "${CMAKE_BINARY_DIR}/cmake_install.cmake" )
  add_dependencies( install-${_group} install-${_component} )
ENDMACRO( SOMA_ADD_COMPONENT _component _group )


#
#
MACRO( SOMA_INSTALL )
  set( _readVariable )
  set( _component )
  foreach( _i ${ARGN} )
    if( _readVariable )
      set( ${_readVariable} "${_i}" )
#       set( _readVariable )
      break()
    else( _readVariable )
      if( "${_i}" STREQUAL COMPONENT )
        set( _readVariable _component )
      endif( "${_i}" STREQUAL COMPONENT )
    endif( _readVariable )
  endforeach( _i ${ARGN} )

  if( NOT _component )
    message( FATAL_ERROR "A component must be defined with SOMA_INSTALL" )
  endif( NOT _component )
  install( ${ARGN} )
ENDMACRO( SOMA_INSTALL _component )


# Copy/pasted from KDE3Macros.cmake
MACRO(SOMA_ADD_MOC_FILES _sources)
   FOREACH (_current_FILE ${ARGN})
      GET_FILENAME_COMPONENT(_tmp_FILE ${_current_FILE} ABSOLUTE)
      GET_FILENAME_COMPONENT(_basename ${_tmp_FILE} NAME_WE)
      SET(_moc ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.moc.cpp)
      ADD_CUSTOM_COMMAND(OUTPUT ${_moc}
         COMMAND ${QT_MOC_EXECUTABLE}
         ARGS ${_tmp_FILE} -o ${_moc}
         DEPENDS ${_tmp_FILE}
      )
      SET(${_sources} ${${_sources}} ${_moc})
   ENDFOREACH (_current_FILE)
ENDMACRO(SOMA_ADD_MOC_FILES)


#
# Usage:
#   SOMA_ADD_SIP_PYTHON_MODULE( <module> <directory> <mainSipFile> [ SIP_SOURCES <file> ... ] [ SIP_INCLUDE <directory> ... ] )
#
#
macro( SOMA_ADD_SIP_PYTHON_MODULE _moduleName _modulePath _mainSipFile )
  # Parse parameters
  set( _SIP_SOURCES )
  set( _SIP_INCLUDE "${CMAKE_CURRENT_SOURCE_DIR}" )
  set( _listVariable )
  foreach( _i ${ARGN} )
    if( "${_i}" STREQUAL "SIP_SOURCES" OR
        "${_i}" STREQUAL "SIP_INCLUDE" )
      set( _listVariable "_${_i}" )
    else( "${_i}" STREQUAL "SIP_SOURCES" OR
        "${_i}" STREQUAL "SIP_INCLUDE" )
      if( _listVariable )
        set( ${_listVariable} ${${_listVariable}} "${_i}" )
      else( _listVariable )
        message( FATAL_ERROR "Invalid option for SOMA_ADD_SIP_PYTHON_MODULE: ${_i}" )
      endif( _listVariable )
    endif( "${_i}" STREQUAL "SIP_SOURCES" OR
        "${_i}" STREQUAL "SIP_INCLUDE" )
  endforeach( _i ${ARGN} )

  # Build install rules for sip files
  SOMA_COPY_FILES( ${PROJECT_NAME}-devel
    "${_mainSipFile}" ${_SIP_SOURCES}
    DESTINATION "share/sip/${PROJECT_NAME}-${${PROJECT_NAME}_VERSION_MAJOR}.${${PROJECT_NAME}_VERSION_MINOR}")

  # Compute C++ file names that will be generated by sip.
  # This is only possible with -j option.
  set( _sipSplitGeneratedCode 8 )
  set(_sipOutputFiles )
  foreach( _i RANGE 0 ${_sipSplitGeneratedCode} )
    if( ${_i} LESS ${_sipSplitGeneratedCode} )
      set(_sipOutputFiles ${_sipOutputFiles} "${CMAKE_CURRENT_BINARY_DIR}/sip${_moduleName}part${_i}.cpp" )
    endif( ${_i} LESS ${_sipSplitGeneratedCode} )
  endforeach( _i RANGE 0 ${_sipSplitGeneratedCode} )

  # Build include options according to _SIP_INCLUDE
  set( _sipIncludeOptions )
  foreach( _i ${_SIP_INCLUDE} )
    set( _sipIncludeOptions ${_sipIncludeOptions} -I "${_i}" )
  endforeach( _i ${_SIP_INCLUDE} )

  # Add rule to generate C++ code with sip
  add_custom_command(
    OUTPUT ${_sipOutputFiles}
    # Sip can generate less files than requested. The touch
    # command make sure that all the files are created (necessary)
    # for dependencies).
    COMMAND ${CMAKE_COMMAND} -E touch ${_sipOutputFiles}
    COMMAND ${SIP_EXECUTABLE}
            -j ${_sipSplitGeneratedCode}
            ${_sipIncludeOptions}
            -c "${CMAKE_CURRENT_BINARY_DIR}"
            -e
            -t ALL -t WS_X11 -t Qt_3_3_0
            -x VendorID -x Qt_STYLE_WINDOWSXP -x Qt_STYLE_INTERLACE -x Qt_STYLE_WINDOWSXP
            ${_mainSipFile}
    DEPENDS ${_mainSipFile} ${_SIP_SOURCES}
  )

  # Create library with sip generated files
  add_library( ${_moduleName} MODULE ${_sipOutputFiles} )
  set_target_properties( ${_moduleName} PROPERTIES
                LIBRARY_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/python/${_modulePath}"
                VERSION "${${PROJECT_NAME}_VERSION}"
                PREFIX "" )
  SOMA_INSTALL( TARGETS ${_moduleName} 
                DESTINATION "python/${_modulePath}"
                COMPONENT ${PROJECT_NAME} )
endmacro( SOMA_ADD_SIP_PYTHON_MODULE _moduleName _modulePath _installComponent _installComponentDevel _sipSplitGeneratedCode _mainSipFile )


macro( SOMA_CREATE_CMAKE_CONFIG_FILES )
  set( _prefixForCmakeFiles "share/${PROJECT_NAME}-${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}/cmake" )
  configure_file( cmake/${PROJECT_NAME}-config.cmake.in
                  "${_prefixForCmakeFiles}/${PROJECT_NAME}-config.cmake" 
                  @ONLY )
  configure_file( cmake/${PROJECT_NAME}-config-version.cmake.in
                  "${_prefixForCmakeFiles}/${PROJECT_NAME}-config-version.cmake" 
                  @ONLY )
  install( FILES
          "${CMAKE_BINARY_DIR}/${_prefixForCmakeFiles}/${PROJECT_NAME}-config.cmake"
          "${CMAKE_BINARY_DIR}/${_prefixForCmakeFiles}/${PROJECT_NAME}-config-version.cmake"
          DESTINATION "${_prefixForCmakeFiles}" )
endmacro( SOMA_CREATE_CMAKE_CONFIG_FILES )


function( SOMA_INSTALL_RUNTIME_LIBRARIES )
  set( librariesToInstall )
  foreach( lib ${ARGN} )
    get_filename_component( lib "${lib}" ABSOLUTE )
    if( UNIX OR APPLE )
      file( GLOB lib "${lib}*" )
    endif( UNIX OR APPLE )
    set( librariesToInstall ${librariesToInstall} ${lib} )
  endforeach( lib ${ARGN} )
  SOMA_INSTALL( FILES ${librariesToInstall}
                DESTINATION lib
                COMPONENT system-runtime )
endfunction( SOMA_INSTALL_RUNTIME_LIBRARIES )


macro( SOMA_INCLUDE_PROJECT_SOURCES _project _version )
  string( REGEX REPLACE "([^.]+)\\.([^.]+)(\\.(.*))?" "\\1" _versionMajor "${_version}")
  string( REGEX REPLACE "([^.]+)\\.([^.]+)(\\.(.*))?" "\\2" _versionMinor "${_version}")
  string( REGEX REPLACE "([^.]+)\\.([^.]+)\\.?(.*)" "\\3" _versionPatch "${_version}")

  set( _found FALSE )
  file( GLOB _sourceDirectories "$ENV{P4}/${_project}/*" "$ENV{P4}/trunk/${_project}" )
  foreach( _sourceDir ${_sourceDirectories} )
    if( EXISTS "${_sourceDir}/project_info.cmake" )
      # TODO: check that the version is correct
      set( _found TRUE )
      message( STATUS "${_project} source directory is \"${_sourceDir}\"." )
      set( SOMA_BUILD_PROJECTS ${SOMA_BUILD_PROJECTS} ${_project} )
      add_subdirectory( "${_sourceDir}" "build_files/${_project}" )
      break()
    endif( EXISTS "${_sourceDir}/project_info.cmake" )
  endforeach( _sourceDir ${_sourceDirectories} )
  if( NOT _found )
    message( FATAL_ERROR "Cannot find sources of ${_project}." )
  endif( NOT _found )
endmacro( SOMA_INCLUDE_PROJECT_SOURCES )
